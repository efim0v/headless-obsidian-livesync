{
  "version": 3,
  "sources": ["DialogHost.svelte", "DialogHeader.svelte", "Question.svelte", "Option.svelte", "Check.svelte", "PanelCouchDBCheck.svelte", "LogPane.svelte", "JsonResolvePane.svelte", "PluginCombo.svelte", "PluginPane.svelte", "TestPane.svelte", "GlobalHistory.svelte", "PeerStatusRow.svelte", "P2PReplicatorPane.svelte", "DialogueToCopy.svelte", "InfoTable.svelte", "MultipleRegExpControl.svelte", "LogsTab.svelte", "DashboardTab.svelte", "ConfirmHost.svelte"],
  "sourcesContent": ["<script lang=\"ts\">import {} from \"./svelteDialog\";\nconst { setTitle, closeDialog, setResult, mountComponent, getInitialData, onSetupContext } = $props();\nconst contextProps = {\n    setTitle,\n    closeDialog,\n    setResult,\n    getInitialData,\n};\n// Call the onSetupContext function to setup the dialog context\nonSetupContext === null || onSetupContext === void 0 ? void 0 : onSetupContext(contextProps);\n/**\n * Wrapper around setResult to also close the dialog\n * @param result\n */\nconst setResultWrapper = (result) => {\n    setResult(result);\n    closeDialog();\n};\nconst Component = mountComponent;\nlet thisElement;\n</script>\n\n<div class=\"dialog-host\" bind:this={thisElement}>\n    <Component setResult={setResultWrapper} {getInitialData}></Component>\n</div>\n\n<style>\n    .dialog-host {\n        padding: 20px;\n        gap: 0.5em;\n        display: flex;\n        flex-direction: column;\n        padding-bottom: var(--keyboard-height, 0px);\n    }\n\n    .dialog-host :global(button) {\n        margin-left: 10px;\n    }\n\n    .dialog-host :global(.button-group) {\n        display: flex;\n        flex-direction: column;\n        gap: 10px;\n        margin-top: 20px;\n    }\n\n    .dialog-host :global(.row) {\n        display: flex;\n        flex-direction: row;\n        justify-items: center;\n        align-items: center;\n        flex-wrap: wrap;\n    }\n\n    .dialog-host :global(.row > input[type=\"text\"]),\n    .dialog-host :global(.row > input[type=\"password\"]),\n    .dialog-host :global(.row > textarea),\n    .dialog-host :global(.row > select) {\n        flex: 1;\n        margin-left: 10px;\n        min-width: 10em;\n    }\n    .dialog-host :global(.row > input[type=\"password\"]) {\n        -webkit-text-security: disc;\n    }\n\n    .dialog-host :global(.row > input[type=\"checkbox\"]) {\n        margin-left: 10px;\n        margin-right: 10px;\n    }\n\n    .dialog-host :global(label > span) {\n        display: block;\n        width: 8em;\n    }\n\n    .dialog-host :global(.note),\n    .dialog-host :global(.note-important),\n    .dialog-host :global(.note-error) {\n        padding: 10px;\n        margin-top: 4px;\n        margin-bottom: 0.5lh;\n        border-left: 4px solid;\n    }\n\n    .dialog-host :global(.note) {\n        background-color: var(--interactive-hover);\n        border-left-color: var(--interactive-accent);\n    }\n    .dialog-host :global(.note-important) {\n        background-color: var(--interactive-hover);\n        border-left-color: var(--text-warning);\n    }\n    .dialog-host :global(.note-error) {\n        background-color: var(--interactive-hover);\n        border-left-color: var(--text-error);\n    }\n    .dialog-host :global(hr) {\n        margin: 0.7lh 0;\n    }\n    .dialog-host :global(details) {\n        gap: 0.5em;\n        padding-left: 0.5em;\n        border-left: 2px solid var(--interactive-accent);\n    }\n    .dialog-host :global(summary::marker) {\n        display: none;\n        content: \"\";\n    }\n\n    .dialog-host :global(summary) {\n        border-left: 4px solid var(--interactive-accent);\n        padding-left: 0.5em;\n        cursor: pointer;\n        outline: none;\n    }\n    .dialog-host :global(details > summary::after) {\n        content: \"‚è∑\";\n        float: right;\n        margin-right: 0.5em;\n    }\n    .dialog-host :global(details[open] > summary::after) {\n        content: \"‚è∂\";\n        float: right;\n        margin-right: 0.5em;\n    }\n\n    .dialog-host :global(input:invalid),\n    .dialog-host :global(textarea:invalid) {\n        border-color: var(--background-modifier-error);\n    }\n    .dialog-host :global(.sub-section) {\n        margin-left: 1em;\n        display: flex;\n        flex-direction: column;\n        gap: 0.5em;\n    }\n\n    .dialog-host :global(.row > input[type=\"text\"]:disabled),\n    .dialog-host :global(.row > input[type=\"password\"]:disabled),\n    .dialog-host :global(.row > textarea:disabled),\n    .dialog-host :global(.row > select:disabled) {\n        background-color: var(--background-secondary);\n    }\n</style>\n", "<script lang=\"ts\">import { onMount, tick } from \"svelte\";\nimport { getDialogContext } from \"../svelteDialog.ts\";\nlet { title = $bindable(), subtitle, children } = $props();\n$effect(() => {\n    if (title) {\n        context.setTitle(`${title}${subtitle ? ` - ${subtitle}` : \"\"}`);\n    }\n});\nconst context = getDialogContext();\nonMount(async () => {\n    var _a;\n    context.setTitle(`${title}${subtitle ? ` - ${subtitle}` : \"\"}`);\n    await tick();\n    (_a = document.querySelector(\".modal\")) === null || _a === void 0 ? void 0 : _a.scrollTo(0, 0);\n});\n</script>\n\n<div class=\"dialog-header\">\n    <h2>{title}</h2>\n    {#if subtitle}\n        <h4>{subtitle}</h4>\n    {/if}\n</div>\n\n<style>\n    .dialog-header {\n        display: none;\n    }\n</style>\n", "<script lang=\"ts\">import { setContext } from \"svelte\";\nconst { children, question } = $props();\nconst questionGroupID = Math.random().toString(36).substring(2, 15);\nsetContext(\"radioGroup\", questionGroupID);\n</script>\n\n<div class=\"question-container\">\n    {#if question}<h3>{@render question?.()}</h3>{/if}\n    <div class=\"question-content\">\n        {@render children?.()}\n    </div>\n</div>\n\n<style>\n    .question-container {\n        border-bottom: 2px solid var(--interactive-accent);\n        margin-bottom: 0.5lh;\n        padding-bottom: 0.5lh;\n    }\n</style>\n\n", "<script lang=\"ts\">import { getContext } from \"svelte\";\nconst definedGroupContext = getContext(\"radioGroup\");\nlet { title, value = $bindable(), noteOnSelected, noteOnUnselected, selectedValue, group, children, } = $props();\nconst actualGroup = group !== null && group !== void 0 ? group : definedGroupContext;\n</script>\n\n<div class=\"option-container {value === selectedValue ? 'selected' : ''}\">\n    <label>\n        <div class=\"choice-row\">\n            <input type=\"radio\" bind:group={value} name={actualGroup} value={selectedValue} />\n            <span class=\"choice-title\">{title}</span>\n        </div>\n        <div class=\"choice-notes\">\n            {#if value === selectedValue && noteOnSelected}\n                {@render noteOnSelected()}\n            {:else if value !== selectedValue && noteOnUnselected}\n                {@render noteOnUnselected()}\n            {/if}\n            {@render children?.()}\n        </div>\n    </label>\n</div>\n\n<style>\n    .option-container {\n        border: 1px solid transparent;\n        border-radius: 0.25lh;\n        padding: 0.5rem;\n    }\n    .option-container.selected {\n        border-color: var(--interactive-accent);\n    }\n    .choice-row {\n        display: flex;\n        align-items: center;\n        gap: 0.5rem;\n        /* margin-top: 1rem; */\n        cursor: pointer;\n    }\n    .choice-row span.choice-title {\n        width: auto;\n    }\n    .choice-row input[type=\"radio\"] {\n        /* width: 1.2rem;\n        height: 1.2rem; */\n        cursor: pointer;\n    }\n\n    .choice-notes {\n        margin-left: 2rem;\n        margin-top: 0.25rem;\n        color: var(--text-muted);\n        font-size: 0.9rem;\n    }\n\n    .option-container.selected .choice-notes {\n        color: var(--text-normal);\n    }\n</style>\n", "<script lang=\"ts\">\"use strict\";\nlet { title, value = $bindable(), noteOnSelected, noteOnUnselected, children } = $props();\n</script>\n\n<label class=\"choice-row\">\n    <input type=\"checkbox\" bind:checked={value} />\n    <span class=\"choice-title\">{title}</span>\n</label>\n<div class=\"choice-notes\">\n    <!-- TODO Highlight selected option -->\n    {#if value && noteOnSelected}\n        {@render noteOnSelected()}\n    {:else if !value && noteOnUnselected}\n        {@render noteOnUnselected()}\n    {/if}\n    {@render children?.()}\n</div>\n\n<style>\n    .choice-row {\n        display: flex;\n        align-items: center;\n        gap: 0.5rem;\n        margin-top: 1rem;\n        cursor: pointer;\n    }\n    .choice-row span.choice-title {\n        width: auto;\n    }\n    .choice-row input[type=\"checkbox\"] {\n        /* width: 1.2rem;\n        height: 1.2rem; */\n        cursor: pointer;\n    }\n\n    .choice-notes {\n        margin-left: 2rem;\n        margin-top: 0.25rem;\n        color: var(--text-muted);\n        font-size: 0.9rem;\n    }\n</style>\n", "<script lang=\"ts\">import Decision from \"../../../../lib/src/UI/components/Decision.svelte\";\nimport UserDecisions from \"../../../../lib/src/UI/components/UserDecisions.svelte\";\nimport { checkConfig } from \"./utilCheckCouchDB\";\nconst { trialRemoteSetting } = $props();\nlet detectedIssues = $state([]);\nasync function testAndFixSettings() {\n    detectedIssues = [];\n    try {\n        const fixResults = await checkConfig(trialRemoteSetting);\n        console.dir(fixResults);\n        detectedIssues = fixResults;\n    }\n    catch (e) {\n        console.error(\"Error during testAndFixSettings:\", e);\n        detectedIssues.push({ message: `Error during testAndFixSettings: ${e}`, result: \"error\", classes: [] });\n    }\n}\nfunction isErrorResult(result) {\n    return \"result\" in result && result.result === \"error\";\n}\nfunction isFixableError(result) {\n    return isErrorResult(result) && \"fix\" in result && typeof result.fix === \"function\";\n}\nfunction isSuccessResult(result) {\n    return \"result\" in result && result.result === \"ok\";\n}\nlet processing = $state(false);\nasync function fixIssue(issue) {\n    try {\n        processing = true;\n        await issue.fix();\n    }\n    catch (e) {\n        console.error(\"Error during fixIssue:\", e);\n    }\n    await testAndFixSettings();\n    processing = false;\n}\nconst errorIssueCount = $derived.by(() => {\n    return detectedIssues.filter((issue) => isErrorResult(issue)).length;\n});\nconst isAllSuccess = $derived.by(() => {\n    return !(errorIssueCount > 0 && detectedIssues.length > 0);\n});\n</script>\n\n{#snippet result(issue: ConfigCheckResult)}\n    <div class=\"check-result {isErrorResult(issue) ? 'error' : isSuccessResult(issue) ? 'success' : ''}\">\n        <div class=\"message\">\n            {issue.message}\n        </div>\n        {#if isFixableError(issue)}\n            <div class=\"operations\">\n                <button onclick={() => fixIssue(issue)} class=\"mod-cta\" disabled={processing}>Fix</button>\n            </div>\n        {/if}\n    </div>\n{/snippet}\n<UserDecisions>\n    <Decision title=\"Detect and Fix CouchDB Issues\" important={true} commit={testAndFixSettings} />\n</UserDecisions>\n<div class=\"check-results\">\n    <details open={!isAllSuccess}>\n        <summary>\n            {#if detectedIssues.length === 0}\n                No checks have been performed yet.\n            {:else if isAllSuccess}\n                All checks passed successfully!\n            {:else}\n                {errorIssueCount} issue(s) detected!\n            {/if}\n        </summary>\n        {#if detectedIssues.length > 0}\n            <h3>Issue detection log:</h3>\n            {#each detectedIssues as issue}\n                {@render result(issue)}\n            {/each}\n        {/if}\n    </details>\n</div>\n\n<style>\n    /* Make .check-result a CSS Grid: let .message expand and keep .operations at minimum width, aligned to the right */\n    .check-results {\n        /* Adjust spacing as required */\n        margin-top: 0.75rem;\n    }\n\n    .check-result {\n        display: grid;\n        grid-template-columns: 1fr auto; /* message takes remaining space, operations use minimum width */\n        align-items: center; /* vertically centre align */\n        gap: 0.5rem 1rem;\n        padding: 0rem 0.5rem;\n        border-radius: 0;\n        box-shadow: none;\n        border-left: 0.5em solid var(--interactive-accent);\n        margin-bottom: 0.25lh;\n    }\n    .check-result.error {\n        border-left: 0.5em solid var(--text-error);\n    }\n    .check-result.success {\n        border-left: 0.5em solid var(--text-success);\n    }\n\n    .check-result .message {\n        /* Wrap long messages */\n        white-space: normal;\n        word-break: break-word;\n        font-size: 0.95rem;\n        color: var(--text-normal);\n    }\n\n    .check-result .operations {\n        /* Centre the button(s) vertically and align to the right */\n        display: flex;\n        align-items: center;\n        justify-content: flex-end;\n        gap: 0.5rem;\n    }\n\n    /* For small screens: move .operations below and stack vertically */\n    @media (max-width: 520px) {\n        .check-result {\n            grid-template-columns: 1fr;\n            grid-auto-rows: auto;\n        }\n        .check-result .operations {\n            justify-content: flex-start;\n            margin-top: 0.5rem;\n        }\n    }\n</style>\n", "<script lang=\"ts\">import { onDestroy, onMount } from \"svelte\";\nimport { logMessages } from \"../../../lib/src/mock_and_interop/stores\";\nimport { reactive } from \"octagonal-wheels/dataobject/reactive\";\nimport { Logger } from \"../../../lib/src/common/logger\";\nimport { $msg as msg, currentLang as lang } from \"../../../lib/src/common/i18n.ts\";\nlet unsubscribe;\nlet messages = $state([]);\nlet wrapRight = $state(false);\nlet autoScroll = $state(true);\nlet suspended = $state(false);\nlet { close } = $props();\n// export let close: () => void;\nfunction updateLog(logs) {\n    const e = logs.value;\n    if (!suspended) {\n        messages = [...e];\n        setTimeout(() => {\n            if (scroll)\n                scroll.scrollTop = scroll.scrollHeight;\n        }, 10);\n    }\n}\nonMount(async () => {\n    const _logMessages = reactive(() => logMessages.value);\n    _logMessages.onChanged(updateLog);\n    Logger(msg(\"logPane.logWindowOpened\", {}, lang));\n    unsubscribe = () => _logMessages.offChanged(updateLog);\n});\nonDestroy(() => {\n    if (unsubscribe)\n        unsubscribe();\n});\nlet scroll;\nfunction closeDialogue() {\n    close();\n}\n</script>\n\n<div class=\"logpane\">\n  <!-- <h1>{msg(\"logPane.title\", {}, lang)}</h1> -->\n  <div class=\"control\">\n      <div class=\"row\">\n          <label>\n              <input type=\"checkbox\" bind:checked={wrapRight} />\n              <span>{msg(\"logPane.wrap\", {}, lang)}</span>\n          </label>\n          <label>\n              <input type=\"checkbox\" bind:checked={autoScroll} />\n              <span>{msg(\"logPane.autoScroll\", {}, lang)}</span>\n          </label>\n          <label>\n              <input type=\"checkbox\" bind:checked={suspended} />\n              <span>{msg(\"logPane.pause\", {}, lang)}</span>\n          </label>\n            <span class=\"spacer\"></span>\n            <button onclick={() => closeDialogue()}>Close</button>\n      </div>\n  </div>\n  <div class=\"log\" bind:this={scroll}>\n      {#each messages as line}\n          <pre class:wrap-right={wrapRight}>{line}</pre>\n      {/each}\n  </div>\n</div>\n\n<style>\n  * {\n      box-sizing: border-box;\n  }\n  .logpane {\n      display: flex;\n      height: 100%;\n      flex-direction: column;\n  }\n  .log {\n      overflow-y: scroll;\n      user-select: text;\n        -webkit-user-select: text;\n      padding-bottom: 2em;\n  }\n  .log > pre {\n      margin: 0;\n  }\n  .log > pre.wrap-right {\n      word-break: break-all;\n      max-width: 100%;\n      width: 100%;\n      white-space: normal;\n  }\n  .row {\n      display: flex;\n      flex-direction: row;\n      justify-content: flex-end;\n  }\n  .row > label {\n      display: flex;\n      align-items: center;\n      min-width: 5em;\n      margin-right: 1em;\n  }\n</style>\n", "<script lang=\"ts\">import { DIFF_DELETE, DIFF_INSERT, diff_match_patch } from \"../../deps.ts\";\nimport { decodeBinary, readString } from \"../../lib/src/string_and_binary/convert.ts\";\nimport { getDocData, isObjectDifferent, mergeObject } from \"../../lib/src/common/utils.ts\";\nlet { docs = $bindable([]), callback = $bindable((async (_, __) => {\n    Promise.resolve();\n})), filename = $bindable(\"\"), nameA = $bindable(\"A\"), nameB = $bindable(\"B\"), defaultSelect = $bindable(\"\"), keepOrder = $bindable(false), hideLocal = $bindable(false), } = $props();\nconst docsArray = $derived.by(() => {\n    if (docs && docs.length >= 1) {\n        if (keepOrder || docs[0].mtime < docs[1].mtime) {\n            return { a: docs[0], b: docs[1] };\n        }\n        else {\n            return { a: docs[1], b: docs[0] };\n        }\n    }\n    return { a: false, b: false };\n});\nconst docA = $derived(docsArray.a);\nconst docB = $derived(docsArray.b);\nconst docAContent = $derived(docA && docToString(docA));\nconst docBContent = $derived(docB && docToString(docB));\nfunction parseJson(json) {\n    if (json === false)\n        return false;\n    try {\n        return JSON.parse(json);\n    }\n    catch (ex) {\n        return false;\n    }\n}\nconst objA = $derived(parseJson(docAContent) || {});\nconst objB = $derived(parseJson(docBContent) || {});\nconst objAB = $derived(mergeObject(objA, objB));\nconst objBAw = $derived(mergeObject(objB, objA));\nconst objBA = $derived(isObjectDifferent(objBAw, objAB) ? objBAw : false);\nlet diffs = $derived.by(() => (objA && selectedObj ? getJsonDiff(objA, selectedObj) : []));\nlet mode = $state(defaultSelect);\nfunction docToString(doc) {\n    return doc.datatype == \"plain\" ? getDocData(doc.data) : readString(new Uint8Array(decodeBinary(doc.data)));\n}\nfunction revStringToRevNumber(rev) {\n    if (!rev)\n        return \"\";\n    return rev.split(\"-\")[0];\n}\nfunction getDiff(left, right) {\n    const dmp = new diff_match_patch();\n    const mapLeft = dmp.diff_linesToChars_(left, right);\n    const diffLeftSrc = dmp.diff_main(mapLeft.chars1, mapLeft.chars2, false);\n    dmp.diff_charsToLines_(diffLeftSrc, mapLeft.lineArray);\n    return diffLeftSrc;\n}\nfunction getJsonDiff(a, b) {\n    return getDiff(JSON.stringify(a, null, 2), JSON.stringify(b, null, 2));\n}\nfunction apply() {\n    if (!docA || !docB)\n        return;\n    if (docA._id == docB._id) {\n        if (mode == \"A\")\n            return callback(docA._rev, undefined);\n        if (mode == \"B\")\n            return callback(docB._rev, undefined);\n    }\n    else {\n        if (mode == \"A\")\n            return callback(undefined, docToString(docA));\n        if (mode == \"B\")\n            return callback(undefined, docToString(docB));\n    }\n    if (mode == \"BA\")\n        return callback(undefined, JSON.stringify(objBA, null, 2));\n    if (mode == \"AB\")\n        return callback(undefined, JSON.stringify(objAB, null, 2));\n    callback(undefined, undefined);\n}\nfunction cancel() {\n    callback(undefined, undefined);\n}\nconst mergedObjs = $derived.by(() => ({\n    \"\": false,\n    A: objA,\n    B: objB,\n    AB: objAB,\n    BA: objBA,\n}));\nlet selectedObj = $derived(mode in mergedObjs ? mergedObjs[mode] : {});\nlet modesSrc = $state([]);\nconst modes = $derived.by(() => {\n    let newModes = [];\n    if (!hideLocal) {\n        newModes.push([\"\", \"Not now\"]);\n        newModes.push([\"A\", nameA || \"A\"]);\n    }\n    newModes.push([\"B\", nameB || \"B\"]);\n    newModes.push([\"AB\", `${nameA || \"A\"} + ${nameB || \"B\"}`]);\n    newModes.push([\"BA\", `${nameB || \"B\"} + ${nameA || \"A\"}`]);\n    return newModes;\n});\n</script>\n\n<h2>{filename}</h2>\n{#if !docA || !docB}\n    <div class=\"message\">Just for a minute, please!</div>\n    <div class=\"buttons\">\n        <button onclick={apply}>Dismiss</button>\n    </div>\n{:else}\n    <div class=\"options\">\n        {#each modes as m}\n            {#if m[0] == \"\" || mergedObjs[m[0]] != false}\n                <label class={`sls-setting-label ${m[0] == mode ? \"selected\" : \"\"}`}\n                    ><input type=\"radio\" name=\"disp\" bind:group={mode} value={m[0]} class=\"sls-setting-tab\" />\n                    <div class=\"sls-setting-menu-btn\">{m[1]}</div></label\n                >\n            {/if}\n        {/each}\n    </div>\n\n    {#if selectedObj != false}\n        <div class=\"op-scrollable json-source\">\n            {#each diffs as diff}\n                <span class={diff[0] == DIFF_DELETE ? \"deleted\" : diff[0] == DIFF_INSERT ? \"added\" : \"normal\"}\n                    >{diff[1]}</span\n                >\n            {/each}\n        </div>\n    {:else}\n        NO PREVIEW\n    {/if}\n\n    <div class=\"infos\">\n        <table>\n            <tbody>\n                <tr>\n                    <th>{nameA}</th>\n                    <td\n                        >{#if docA._id == docB._id}\n                            Rev:{revStringToRevNumber(docA._rev)}\n                        {/if}\n                        {new Date(docA.mtime).toLocaleString()}</td\n                    >\n                    <td>\n                        {docAContent && docAContent.length} letters\n                    </td>\n                </tr>\n                <tr>\n                    <th>{nameB}</th>\n                    <td\n                        >{#if docA._id == docB._id}\n                            Rev:{revStringToRevNumber(docB._rev)}\n                        {/if}\n                        {new Date(docB.mtime).toLocaleString()}</td\n                    >\n                    <td>\n                        {docBContent && docBContent.length} letters\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n\n    <div class=\"buttons\">\n        {#if hideLocal}\n            <button onclick={cancel}>Cancel</button>\n        {/if}\n        <button onclick={apply}>Apply</button>\n    </div>\n{/if}\n\n<style>\n    .spacer {\n        flex-grow: 1;\n    }\n    .infos {\n        display: flex;\n        justify-content: space-between;\n        margin: 4px 0.5em;\n    }\n\n    .deleted {\n        text-decoration: line-through;\n    }\n    * {\n        box-sizing: border-box;\n    }\n\n    .scroller {\n        display: flex;\n        flex-direction: column;\n        overflow-y: scroll;\n        max-height: 60vh;\n        user-select: text;\n        -webkit-user-select: text;\n    }\n    .json-source {\n        white-space: pre;\n        height: auto;\n        overflow: auto;\n        min-height: var(--font-ui-medium);\n        flex-grow: 1;\n    }\n</style>\n", "<script lang=\"ts\">import { ConfigSync, PluginDataExDisplayV2, } from \"./CmdConfigSync.ts\";\nimport { Logger } from \"../../lib/src/common/logger\";\nimport { LOG_LEVEL_INFO, LOG_LEVEL_NOTICE, LOG_LEVEL_VERBOSE } from \"../../lib/src/common/types\";\nimport { getDocData, timeDeltaToHumanReadable, unique } from \"../../lib/src/common/utils\";\n// import { askString } from \"../../common/utils\";\nimport { Menu } from \"obsidian\";\nexport let list = [];\nexport let thisTerm = \"\";\nexport let hideNotApplicable = false;\nexport let selectNewest = 0;\nexport let selectNewestStyle = 0;\nexport let applyAllPluse = 0;\nexport let applyData;\nexport let compareData;\nexport let deleteData;\nexport let hidden;\nexport let plugin;\nexport let isMaintenanceMode = false;\nexport let isFlagged = false;\nconst addOn = plugin.getAddOn(ConfigSync.name);\nif (!addOn) {\n    Logger(`Could not load the add-on ${ConfigSync.name}`, LOG_LEVEL_INFO);\n    throw new Error(`Could not load the add-on ${ConfigSync.name}`);\n}\nexport let selected = \"\";\nlet freshness = \"\";\nlet equivalency = \"\";\nlet version = \"\";\nlet canApply = false;\nlet canCompare = false;\nlet pickToCompare = false;\nlet currentSelectNewest = 0;\nlet currentApplyAll = 0;\n// Selectable terminals\nlet terms = [];\nasync function comparePlugin(local, remote) {\n    var _a, _b;\n    let freshness = \"\";\n    let equivalency = \"\";\n    let version = \"\";\n    let contentCheck = false;\n    let canApply = false;\n    let canCompare = false;\n    if (!local && !remote) {\n        // NO OP. what's happened?\n        freshness = \"\";\n    }\n    else if (local && !remote) {\n        freshness = \"Local only\";\n    }\n    else if (remote && !local) {\n        freshness = \"Remote only\";\n        canApply = true;\n    }\n    else {\n        const dtDiff = ((_a = local === null || local === void 0 ? void 0 : local.mtime) !== null && _a !== void 0 ? _a : 0) - ((_b = remote === null || remote === void 0 ? void 0 : remote.mtime) !== null && _b !== void 0 ? _b : 0);\n        const diff = timeDeltaToHumanReadable(Math.abs(dtDiff));\n        if (dtDiff / 1000 < -10) {\n            // freshness = \"‚úì Newer\";\n            freshness = `Newer (${diff})`;\n            canApply = true;\n            contentCheck = true;\n        }\n        else if (dtDiff / 1000 > 10) {\n            // freshness = \"‚ö† Older\";\n            freshness = `Older (${diff})`;\n            canApply = true;\n            contentCheck = true;\n        }\n        else {\n            freshness = \"Same\";\n            canApply = false;\n            contentCheck = true;\n        }\n    }\n    const localVersionStr = (local === null || local === void 0 ? void 0 : local.version) || \"0.0.0\";\n    const remoteVersionStr = (remote === null || remote === void 0 ? void 0 : remote.version) || \"0.0.0\";\n    if ((local === null || local === void 0 ? void 0 : local.version) || (remote === null || remote === void 0 ? void 0 : remote.version)) {\n        const compare = `${localVersionStr}`.localeCompare(remoteVersionStr, undefined, { numeric: true });\n        if (compare == 0) {\n            version = \"Same\";\n        }\n        else if (compare < 0) {\n            version = `Lower (${localVersionStr} < ${remoteVersionStr})`;\n        }\n        else if (compare > 0) {\n            version = `Higher (${localVersionStr} > ${remoteVersionStr})`;\n        }\n    }\n    if (contentCheck) {\n        if (local && remote) {\n            const { canApply, equivalency, canCompare } = await checkEquivalency(local, remote);\n            return { canApply, freshness, equivalency, version, canCompare };\n        }\n    }\n    return { canApply, freshness, equivalency, version, canCompare };\n}\nasync function checkEquivalency(local, remote) {\n    let equivalency = \"\";\n    let canApply = false;\n    let canCompare = false;\n    const filenames = [...new Set([...local.files.map((e) => e.filename), ...remote.files.map((e) => e.filename)])];\n    const matchingStatus = filenames\n        .map((filename) => {\n        const localFile = local.files.find((e) => e.filename == filename);\n        const remoteFile = remote.files.find((e) => e.filename == filename);\n        if (!localFile && !remoteFile) {\n            return 0b0000000;\n        }\n        else if (localFile && !remoteFile) {\n            return 0b0000010; //\"LOCAL_ONLY\";\n        }\n        else if (!localFile && remoteFile) {\n            return 0b0001000; //\"REMOTE ONLY\"\n        }\n        else if (localFile && remoteFile) {\n            const localDoc = getDocData(localFile.data);\n            const remoteDoc = getDocData(remoteFile.data);\n            if (localDoc == remoteDoc) {\n                return 0b0000100; //\"EVEN\"\n            }\n            else {\n                return 0b0010000; //\"DIFFERENT\";\n            }\n        }\n        else {\n            return 0b0010000; //\"DIFFERENT\";\n        }\n    })\n        .reduce((p, c) => p | c, 0);\n    if (matchingStatus == 0b0000100) {\n        equivalency = \"Same\";\n        canApply = false;\n    }\n    else if (matchingStatus <= 0b0000100) {\n        equivalency = \"Same or local only\";\n        canApply = false;\n    }\n    else if (matchingStatus == 0b0010000) {\n        canApply = true;\n        canCompare = true;\n        equivalency = \"Different\";\n    }\n    else {\n        canApply = true;\n        canCompare = true;\n        equivalency = \"Mixed\";\n    }\n    return { equivalency, canApply, canCompare };\n}\nasync function performCompare(local, remote) {\n    const result = await comparePlugin(local, remote);\n    canApply = result.canApply;\n    freshness = result.freshness;\n    equivalency = result.equivalency;\n    version = result.version;\n    canCompare = result.canCompare;\n    pickToCompare = false;\n    if (canCompare) {\n        if ((local === null || local === void 0 ? void 0 : local.files.length) == (remote === null || remote === void 0 ? void 0 : remote.files.length) &&\n            (local === null || local === void 0 ? void 0 : local.files.length) == 1 &&\n            (local === null || local === void 0 ? void 0 : local.files[0].filename) == (remote === null || remote === void 0 ? void 0 : remote.files[0].filename)) {\n            pickToCompare = false;\n        }\n        else {\n            pickToCompare = true;\n            // pickToCompare = false;\n            // canCompare = false;\n        }\n    }\n}\nasync function updateTerms(list, selectNewest, isMaintenanceMode) {\n    const local = list.find((e) => e.term == thisTerm);\n    // selected = \"\";\n    if (isMaintenanceMode) {\n        terms = [...new Set(list.map((e) => e.term))];\n    }\n    else if (hideNotApplicable) {\n        const termsTmp = [];\n        const wk = [...new Set(list.map((e) => e.term))];\n        for (const termName of wk) {\n            const remote = list.find((e) => e.term == termName);\n            if ((await comparePlugin(local, remote)).canApply) {\n                termsTmp.push(termName);\n            }\n        }\n        terms = [...termsTmp];\n    }\n    else {\n        terms = [...new Set(list.map((e) => e.term))].filter((e) => e != thisTerm);\n    }\n    let newest = local;\n    if (selectNewest) {\n        for (const term of terms) {\n            const remote = list.find((e) => e.term == term);\n            if (remote && remote.mtime && ((newest === null || newest === void 0 ? void 0 : newest.mtime) || 0) < remote.mtime) {\n                newest = remote;\n            }\n        }\n        if (newest && newest.term != thisTerm) {\n            selected = newest.term;\n        }\n        // selectNewest = false;\n    }\n    if (terms.indexOf(selected) < 0) {\n        selected = \"\";\n    }\n}\n$: {\n    // React pulse and select\n    let doSelectNewest = false;\n    if (selectNewest != currentSelectNewest) {\n        if (selectNewestStyle == 1) {\n            doSelectNewest = true;\n        }\n        else if (selectNewestStyle == 2) {\n            doSelectNewest = isFlagged;\n        }\n        else if (selectNewestStyle == 3) {\n            selected = \"\";\n        }\n        // currentSelectNewest = selectNewest;\n    }\n    updateTerms(list, doSelectNewest, isMaintenanceMode);\n    currentSelectNewest = selectNewest;\n}\n$: {\n    // React pulse and apply\n    const doApply = applyAllPluse != currentApplyAll;\n    currentApplyAll = applyAllPluse;\n    if (doApply && selected) {\n        if (!hidden) {\n            applySelected();\n        }\n    }\n}\n$: {\n    freshness = \"\";\n    equivalency = \"\";\n    version = \"\";\n    canApply = false;\n    if (selected == \"\") {\n        // NO OP.\n    }\n    else if (selected == thisTerm) {\n        freshness = \"This device\";\n        canApply = false;\n    }\n    else {\n        const local = list.find((e) => e.term == thisTerm);\n        const remote = list.find((e) => e.term == selected);\n        performCompare(local, remote);\n    }\n}\nasync function applySelected() {\n    const local = list.find((e) => e.term == thisTerm);\n    const selectedItem = list.find((e) => e.term == selected);\n    if (selectedItem && (await applyData(selectedItem))) {\n        addOn.updatePluginList(true, local === null || local === void 0 ? void 0 : local.documentPath);\n    }\n}\nasync function compareSelected() {\n    const local = list.find((e) => e.term == thisTerm);\n    const selectedItem = list.find((e) => e.term == selected);\n    await compareItems(local, selectedItem);\n}\nasync function compareItems(local, remote, filename) {\n    if (local && remote) {\n        if (!filename) {\n            if (await compareData(local, remote)) {\n                addOn.updatePluginList(true, local.documentPath);\n            }\n            return;\n        }\n        else {\n            const localCopy = local instanceof PluginDataExDisplayV2 ? new PluginDataExDisplayV2(local) : { ...local };\n            const remoteCopy = remote instanceof PluginDataExDisplayV2 ? new PluginDataExDisplayV2(remote) : { ...remote };\n            localCopy.files = localCopy.files.filter((e) => e.filename == filename);\n            remoteCopy.files = remoteCopy.files.filter((e) => e.filename == filename);\n            if (await compareData(localCopy, remoteCopy, true)) {\n                addOn.updatePluginList(true, local.documentPath);\n            }\n        }\n        return;\n    }\n    else {\n        if (!remote && !local) {\n            Logger(`Could not find both remote and local item`, LOG_LEVEL_INFO);\n        }\n        else if (!remote) {\n            Logger(`Could not find remote item`, LOG_LEVEL_INFO);\n        }\n        else if (!local) {\n            Logger(`Could not locally item`, LOG_LEVEL_INFO);\n        }\n    }\n}\nasync function pickCompareItem(evt) {\n    const local = list.find((e) => e.term == thisTerm);\n    const selectedItem = list.find((e) => e.term == selected);\n    if (!local)\n        return;\n    if (!selectedItem)\n        return;\n    const menu = new Menu();\n    menu.addItem((item) => item.setTitle(\"Compare file\").setIsLabel(true));\n    menu.addSeparator();\n    const files = unique(local.files.map((e) => e.filename).concat(selectedItem.files.map((e) => e.filename)));\n    const convDate = (dt) => {\n        if (!dt)\n            return \"(Missing)\";\n        const d = new Date(dt.mtime);\n        return d.toLocaleString();\n    };\n    for (const filename of files) {\n        menu.addItem((item) => {\n            const localFile = local.files.find((e) => e.filename == filename);\n            const remoteFile = selectedItem.files.find((e) => e.filename == filename);\n            const title = `${filename} (${convDate(localFile)} <--> ${convDate(remoteFile)})`;\n            item.setTitle(title).onClick((e) => compareItems(local, selectedItem, filename));\n        });\n    }\n    menu.showAtMouseEvent(evt);\n}\nasync function deleteSelected() {\n    const selectedItem = list.find((e) => e.term == selected);\n    // const deletedPath = selectedItem.documentPath;\n    if (selectedItem && (await deleteData(selectedItem))) {\n        addOn.reloadPluginList(true);\n    }\n}\nasync function duplicateItem() {\n    const local = list.find((e) => e.term == thisTerm);\n    if (!local) {\n        Logger(`Could not find local item`, LOG_LEVEL_VERBOSE);\n        return;\n    }\n    const duplicateTermName = await plugin.confirm.askString(\"Duplicate\", \"device name\", \"\");\n    if (duplicateTermName) {\n        if (duplicateTermName.contains(\"/\")) {\n            Logger(`We can not use \"/\" to the device name`, LOG_LEVEL_NOTICE);\n            return;\n        }\n        const key = `${plugin.app.vault.configDir}/${local.files[0].filename}`;\n        await addOn.storeCustomizationFiles(key, duplicateTermName);\n        await addOn.updatePluginList(false, addOn.filenameToUnifiedKey(key, duplicateTermName));\n    }\n}\n</script>\n\n{#if terms.length > 0}\n    <span class=\"spacer\"></span>\n    {#if !hidden}\n        <span class=\"chip-wrap\">\n            <span class=\"chip modified\">{freshness}</span>\n            <span class=\"chip content\">{equivalency}</span>\n            <span class=\"chip version\">{version}</span>\n        </span>\n        <select bind:value={selected}>\n            <option value={\"\"}>-</option>\n            {#each terms as term}\n                <option value={term}>{term}</option>\n            {/each}\n        </select>\n        {#if canApply || (isMaintenanceMode && selected != \"\")}\n            {#if canCompare}\n                {#if pickToCompare}\n                    <button on:click={pickCompareItem}>üóÉÔ∏è</button>\n                {:else}\n                    <!--üîç  -->\n                    <button on:click={compareSelected}>‚ÆÇ</button>\n                {/if}\n            {:else}\n                <!-- svelte-ignore a11y_consider_explicit_label -->\n                <button disabled></button>\n            {/if}\n            <button on:click={applySelected}>‚úì</button>\n        {:else}\n            <!-- svelte-ignore a11y_consider_explicit_label -->\n            <button disabled></button>\n            <!-- svelte-ignore a11y_consider_explicit_label -->\n            <button disabled></button>\n        {/if}\n        {#if isMaintenanceMode}\n            {#if selected != \"\"}\n                <button on:click={deleteSelected}>üóëÔ∏è</button>\n            {:else}\n                <button on:click={duplicateItem}>üìë</button>\n            {/if}\n        {/if}\n    {/if}\n{:else}\n    <span class=\"spacer\"></span>\n    <span class=\"message even\">All the same or non-existent</span>\n    <!-- svelte-ignore a11y_consider_explicit_label -->\n    <button disabled></button>\n    <!-- svelte-ignore a11y_consider_explicit_label -->\n    <button disabled></button>\n{/if}\n\n<style>\n    .spacer {\n        min-width: 1px;\n        flex-grow: 1;\n    }\n    button {\n        margin: 2px 4px;\n        min-width: 3em;\n        max-width: 4em;\n    }\n    button:disabled {\n        border: none;\n        box-shadow: none;\n        background-color: transparent;\n        visibility: collapse;\n    }\n    button:disabled:hover {\n        border: none;\n        box-shadow: none;\n        background-color: transparent;\n        visibility: collapse;\n    }\n    span.message {\n        color: var(--text-muted);\n        font-size: var(--font-ui-smaller);\n        padding: 0 1em;\n        line-height: var(--line-height-tight);\n    }\n    /* span.messages {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n    } */\n    :global(.is-mobile) .spacer {\n        margin-left: auto;\n    }\n\n    .chip-wrap {\n        display: flex;\n        gap: 2px;\n        flex-direction: column;\n        justify-content: center;\n        align-items: flex-start;\n    }\n    .chip {\n        display: inline-block;\n        border-radius: 2px;\n        font-size: 0.8em;\n        padding: 0 4px;\n        margin: 0 2px;\n        border-color: var(--tag-border-color);\n        background-color: var(--tag-background);\n        color: var(--tag-color);\n    }\n    .chip:empty {\n        display: none;\n    }\n    .chip:not(:empty)::before {\n        min-width: 1.8em;\n        display: inline-block;\n    }\n    .chip.content:not(:empty)::before {\n        content: \"üìÑ: \";\n    }\n    .chip.version:not(:empty)::before {\n        content: \"üè∑Ô∏è: \";\n    }\n    .chip.modified:not(:empty)::before {\n        content: \"üìÖ: \";\n    }\n</style>\n", "<script lang=\"ts\">import { onMount } from \"svelte\";\nimport ObsidianLiveSyncPlugin from \"../../main\";\nimport { ConfigSync, pluginIsEnumerating, pluginList, pluginManifestStore, pluginV2Progress, } from \"./CmdConfigSync.ts\";\nimport PluginCombo from \"./PluginCombo.svelte\";\nimport { Menu } from \"obsidian\";\nimport { unique } from \"../../lib/src/common/utils\";\nimport { MODE_SELECTIVE, MODE_AUTOMATIC, MODE_PAUSED, MODE_SHINY, } from \"../../lib/src/common/types\";\nimport { normalizePath } from \"../../deps\";\nimport { HiddenFileSync } from \"../HiddenFileSync/CmdHiddenFileSync.ts\";\nimport { LOG_LEVEL_NOTICE, Logger } from \"octagonal-wheels/common/logger\";\nexport let plugin;\n$: hideNotApplicable = false;\n$: thisTerm = plugin.services.setting.getDeviceAndVaultName();\nconst addOn = plugin.getAddOn(ConfigSync.name);\nif (!addOn) {\n    const msg = \"AddOn Module (ConfigSync) has not been loaded. This is very unexpected situation. Please report this issue.\";\n    Logger(msg, LOG_LEVEL_NOTICE);\n    throw new Error(msg);\n}\nconst addOnHiddenFileSync = plugin.getAddOn(HiddenFileSync.name);\nif (!addOnHiddenFileSync) {\n    const msg = \"AddOn Module (HiddenFileSync) has not been loaded. This is very unexpected situation. Please report this issue.\";\n    Logger(msg, LOG_LEVEL_NOTICE);\n    throw new Error(msg);\n}\nlet list = [];\nlet selectNewestPulse = 0;\nlet selectNewestStyle = 0;\nlet hideEven = false;\nlet loading = false;\nlet applyAllPluse = 0;\nlet isMaintenanceMode = false;\nasync function requestUpdate() {\n    await addOn.updatePluginList(true);\n}\nasync function requestReload() {\n    await addOn.reloadPluginList(true);\n}\nlet allTerms = [];\npluginList.subscribe((e) => {\n    list = e;\n    allTerms = unique(list.map((e) => e.term));\n});\npluginIsEnumerating.subscribe((e) => {\n    loading = e;\n});\nonMount(async () => {\n    requestUpdate();\n});\nfunction filterList(list, categories) {\n    const w = list.filter((e) => categories.indexOf(e.category) !== -1);\n    return w.sort((a, b) => `${a.category}-${a.name}`.localeCompare(`${b.category}-${b.name}`));\n}\nfunction groupBy(items, key) {\n    let ret = {};\n    for (const v of items) {\n        //@ts-ignore\n        const k = (key in v ? v[key] : \"\");\n        ret[k] = ret[k] || [];\n        ret[k].push(v);\n    }\n    for (const k in ret) {\n        ret[k] = ret[k].sort((a, b) => `${a.category}-${a.name}`.localeCompare(`${b.category}-${b.name}`));\n    }\n    const w = Object.entries(ret);\n    return w.sort(([a], [b]) => `${a}`.localeCompare(`${b}`));\n}\nconst displays = {\n    CONFIG: \"Configuration\",\n    THEME: \"Themes\",\n    SNIPPET: \"Snippets\",\n};\nasync function scanAgain() {\n    await addOn.scanAllConfigFiles(true);\n    await requestUpdate();\n}\nasync function replicate() {\n    await plugin.services.replication.replicate(true);\n}\nfunction selectAllNewest(selectMode) {\n    selectNewestPulse++;\n    selectNewestStyle = selectMode ? 1 : 2;\n}\nfunction resetSelectNewest() {\n    selectNewestPulse++;\n    selectNewestStyle = 3;\n}\nfunction applyAll() {\n    applyAllPluse++;\n}\nasync function applyData(data) {\n    return await addOn.applyData(data);\n}\nasync function compareData(docA, docB, compareEach = false) {\n    return await addOn.compareUsingDisplayData(docA, docB, compareEach);\n}\nasync function deleteData(data) {\n    return await addOn.deleteData(data);\n}\nfunction askMode(evt, title, key) {\n    var _a;\n    const menu = new Menu();\n    menu.addItem((item) => item.setTitle(title).setIsLabel(true));\n    menu.addSeparator();\n    const prevMode = (_a = automaticList.get(key)) !== null && _a !== void 0 ? _a : MODE_SELECTIVE;\n    for (const mode of [MODE_SELECTIVE, MODE_AUTOMATIC, MODE_PAUSED, MODE_SHINY]) {\n        menu.addItem((item) => {\n            item.setTitle(`${getIcon(mode)}:${TITLES[mode]}`)\n                .onClick((e) => {\n                if (mode === MODE_AUTOMATIC) {\n                    askOverwriteModeForAutomatic(evt, key);\n                }\n                else {\n                    setMode(key, mode);\n                }\n            })\n                .setChecked(prevMode == mode)\n                .setDisabled(prevMode == mode);\n        });\n    }\n    menu.showAtMouseEvent(evt);\n}\nfunction applyAutomaticSync(key, direction) {\n    var _a, _b;\n    setMode(key, MODE_AUTOMATIC);\n    const configDir = normalizePath(plugin.app.vault.configDir);\n    const files = ((_b = (_a = plugin.settings.pluginSyncExtendedSetting[key]) === null || _a === void 0 ? void 0 : _a.files) !== null && _b !== void 0 ? _b : []).map((e) => `${configDir}/${e}`);\n    addOnHiddenFileSync.initialiseInternalFileSync(direction, true, files);\n}\nfunction askOverwriteModeForAutomatic(evt, key) {\n    const menu = new Menu();\n    menu.addItem((item) => item.setTitle(\"Initial Action\").setIsLabel(true));\n    menu.addSeparator();\n    menu.addItem((item) => {\n        item.setTitle(`‚Üë: Overwrite Remote`).onClick((e) => {\n            applyAutomaticSync(key, \"pushForce\");\n        });\n    })\n        .addItem((item) => {\n        item.setTitle(`‚Üì: Overwrite Local`).onClick((e) => {\n            applyAutomaticSync(key, \"pullForce\");\n        });\n    })\n        .addItem((item) => {\n        item.setTitle(`‚áÖ: Use newer`).onClick((e) => {\n            applyAutomaticSync(key, \"safe\");\n        });\n    });\n    menu.showAtMouseEvent(evt);\n}\n$: options = {\n    thisTerm,\n    hideNotApplicable,\n    selectNewest: selectNewestPulse,\n    selectNewestStyle,\n    applyAllPluse,\n    applyData,\n    compareData,\n    deleteData,\n    plugin,\n    isMaintenanceMode,\n};\nconst ICON_EMOJI_PAUSED = `‚õî`;\nconst ICON_EMOJI_AUTOMATIC = `‚ú®`;\nconst ICON_EMOJI_SELECTIVE = `üîÄ`;\nconst ICON_EMOJI_FLAGGED = `üö©`;\nconst ICONS = {\n    [MODE_SELECTIVE]: ICON_EMOJI_SELECTIVE,\n    [MODE_PAUSED]: ICON_EMOJI_PAUSED,\n    [MODE_AUTOMATIC]: ICON_EMOJI_AUTOMATIC,\n    [MODE_SHINY]: ICON_EMOJI_FLAGGED,\n};\nconst TITLES = {\n    [MODE_SELECTIVE]: \"Selective\",\n    [MODE_PAUSED]: \"Ignore\",\n    [MODE_AUTOMATIC]: \"Automatic\",\n    [MODE_SHINY]: \"Flagged Selective\",\n};\nconst PREFIX_PLUGIN_ALL = \"PLUGIN_ALL\";\nconst PREFIX_PLUGIN_DATA = \"PLUGIN_DATA\";\nconst PREFIX_PLUGIN_MAIN = \"PLUGIN_MAIN\";\nconst PREFIX_PLUGIN_ETC = \"PLUGIN_ETC\";\nfunction setMode(key, mode) {\n    if (key.startsWith(PREFIX_PLUGIN_ALL + \"/\")) {\n        setMode(PREFIX_PLUGIN_DATA + key.substring(PREFIX_PLUGIN_ALL.length), mode);\n        setMode(PREFIX_PLUGIN_MAIN + key.substring(PREFIX_PLUGIN_ALL.length), mode);\n        return;\n    }\n    const files = unique(list\n        .filter((e) => `${e.category}/${e.name}` == key)\n        .map((e) => e.files)\n        .flat()\n        .map((e) => e.filename));\n    if (mode == MODE_SELECTIVE) {\n        automaticList.delete(key);\n        delete plugin.settings.pluginSyncExtendedSetting[key];\n        automaticListDisp = automaticList;\n    }\n    else {\n        automaticList.set(key, mode);\n        automaticListDisp = automaticList;\n        if (!(key in plugin.settings.pluginSyncExtendedSetting)) {\n            plugin.settings.pluginSyncExtendedSetting[key] = {\n                key,\n                mode,\n                files: [],\n            };\n        }\n        plugin.settings.pluginSyncExtendedSetting[key].files = files;\n        plugin.settings.pluginSyncExtendedSetting[key].mode = mode;\n    }\n    plugin.services.setting.saveSettingData();\n}\nfunction getIcon(mode) {\n    if (mode in ICONS) {\n        return ICONS[mode];\n    }\n    else {\n        (\"\");\n    }\n}\nlet automaticList = new Map();\nlet automaticListDisp = new Map();\n// apply current configuration to the dialogue\nfor (const { key, mode } of Object.values(plugin.settings.pluginSyncExtendedSetting)) {\n    automaticList.set(key, mode);\n}\nautomaticListDisp = automaticList;\nlet displayKeys = {};\nfunction computeDisplayKeys(list) {\n    const extraKeys = Object.keys(plugin.settings.pluginSyncExtendedSetting);\n    return [\n        ...list,\n        ...extraKeys\n            .map((e) => `${e}///`.split(\"/\"))\n            .filter((e) => e[0] && e[1])\n            .map((e) => ({ category: e[0], name: e[1], displayName: e[1] })),\n    ]\n        .sort((a, b) => { var _a, _b; return ((_a = a.displayName) !== null && _a !== void 0 ? _a : a.name).localeCompare((_b = b.displayName) !== null && _b !== void 0 ? _b : b.name); })\n        .reduce((p, c) => {\n        var _a, _b;\n        return ({\n            ...p,\n            [c.category]: unique(c.category in p ? [...p[c.category], (_a = c.displayName) !== null && _a !== void 0 ? _a : c.name] : [(_b = c.displayName) !== null && _b !== void 0 ? _b : c.name]),\n        });\n    }, {});\n}\n$: {\n    displayKeys = computeDisplayKeys(list);\n}\nlet deleteTerm = \"\";\nasync function deleteAllItems(term) {\n    const deleteItems = list.filter((e) => e.term == term);\n    for (const item of deleteItems) {\n        await deleteData(item);\n    }\n    addOn.reloadPluginList(true);\n}\nlet nameMap = new Map();\nfunction updateNameMap(e) {\n    const items = [...e.entries()].map(([k, v]) => [k.split(\"/\").slice(-2).join(\"/\"), v.name]);\n    const newMap = new Map(items);\n    if (newMap.size == nameMap.size) {\n        let diff = false;\n        for (const [k, v] of newMap) {\n            if (nameMap.get(k) != v) {\n                diff = true;\n                break;\n            }\n        }\n        if (!diff) {\n            return;\n        }\n    }\n    nameMap = newMap;\n}\n$: updateNameMap($pluginManifestStore);\nlet displayEntries = [];\n$: {\n    displayEntries = Object.entries(displays).filter(([key, _]) => key in displayKeys);\n}\nlet pluginEntries = [];\n$: {\n    pluginEntries = groupBy(filterList(list, [\"PLUGIN_MAIN\", \"PLUGIN_DATA\", \"PLUGIN_ETC\"]), \"name\");\n}\nlet useSyncPluginEtc = plugin.settings.usePluginEtc;\n</script>\n\n<div class=\"buttonsWrap\">\n    <div class=\"buttons\">\n        <button on:click={() => scanAgain()}>Scan changes</button>\n        <button on:click={() => replicate()}>Sync once</button>\n        <button on:click={() => requestUpdate()}>Refresh</button>\n        {#if isMaintenanceMode}\n            <button on:click={() => requestReload()}>Reload</button>\n        {/if}\n    </div>\n    <div class=\"buttons\">\n        <button on:click={() => selectAllNewest(true)}>Select All Shiny</button>\n        <button on:click={() => selectAllNewest(false)}>{ICON_EMOJI_FLAGGED} Select Flagged Shiny</button>\n        <button on:click={() => resetSelectNewest()}>Deselect all</button>\n        <button on:click={() => applyAll()} class=\"mod-cta\">Apply All Selected</button>\n    </div>\n</div>\n<div class=\"loading\">\n    {#if loading || $pluginV2Progress !== 0}\n        <span>Updating list...{$pluginV2Progress == 0 ? \"\" : ` (${$pluginV2Progress})`}</span>\n    {/if}\n</div>\n<div class=\"list\">\n    {#if list.length == 0}\n        <div class=\"center\">No Items.</div>\n    {:else}\n        {#each displayEntries as [key, label]}\n            <div>\n                <h3>{label}</h3>\n                {#each displayKeys[key] as name}\n                    {@const bindKey = `${key}/${name}`}\n                    {@const mode = automaticListDisp.get(bindKey) ?? MODE_SELECTIVE}\n                    <div class=\"labelrow {hideEven ? 'hideeven' : ''}\">\n                        <div class=\"title\">\n                            <button class=\"status\" on:click={(evt) => askMode(evt, `${key}/${name}`, bindKey)}>\n                                {getIcon(mode)}\n                            </button>\n                            <span class=\"name\">{(key == \"THEME\" && nameMap.get(`themes/${name}`)) || name}</span>\n                        </div>\n                        <div class=\"body\">\n                            {#if mode == MODE_SELECTIVE || mode == MODE_SHINY}\n                                <PluginCombo\n                                    {...options}\n                                    isFlagged={mode == MODE_SHINY}\n                                    list={list.filter((e) => e.category == key && e.name == name)}\n                                    hidden={false}\n                                />\n                            {:else}\n                                <div class=\"statusnote\">{TITLES[mode]}</div>\n                            {/if}\n                        </div>\n                    </div>\n                {/each}\n            </div>\n        {/each}\n        <div>\n            <h3>Plugins</h3>\n            {#each pluginEntries as [name, listX]}\n                {@const bindKeyAll = `${PREFIX_PLUGIN_ALL}/${name}`}\n                {@const modeAll = automaticListDisp.get(bindKeyAll) ?? MODE_SELECTIVE}\n                {@const bindKeyMain = `${PREFIX_PLUGIN_MAIN}/${name}`}\n                {@const modeMain = automaticListDisp.get(bindKeyMain) ?? MODE_SELECTIVE}\n                {@const bindKeyData = `${PREFIX_PLUGIN_DATA}/${name}`}\n                {@const modeData = automaticListDisp.get(bindKeyData) ?? MODE_SELECTIVE}\n                {@const bindKeyETC = `${PREFIX_PLUGIN_ETC}/${name}`}\n                {@const modeEtc = automaticListDisp.get(bindKeyETC) ?? MODE_SELECTIVE}\n                <div class=\"labelrow {hideEven ? 'hideeven' : ''}\">\n                    <div class=\"title\">\n                        <button\n                            class=\"status\"\n                            on:click={(evt) => askMode(evt, `${PREFIX_PLUGIN_ALL}/${name}`, bindKeyAll)}\n                        >\n                            {getIcon(modeAll)}\n                        </button>\n                        <span class=\"name\">{nameMap.get(`plugins/${name}`) || name}</span>\n                    </div>\n                    <div class=\"body\">\n                        {#if modeAll == MODE_SELECTIVE || modeAll == MODE_SHINY}\n                            <PluginCombo {...options} isFlagged={modeAll == MODE_SHINY} list={listX} hidden={true} />\n                        {/if}\n                    </div>\n                </div>\n                {#if modeAll == MODE_SELECTIVE || modeAll == MODE_SHINY}\n                    <div class=\"filerow {hideEven ? 'hideeven' : ''}\">\n                        <div class=\"filetitle\">\n                            <button\n                                class=\"status\"\n                                on:click={(evt) => askMode(evt, `${PREFIX_PLUGIN_MAIN}/${name}/MAIN`, bindKeyMain)}\n                            >\n                                {getIcon(modeMain)}\n                            </button>\n                            <span class=\"name\">MAIN</span>\n                        </div>\n                        <div class=\"body\">\n                            {#if modeMain == MODE_SELECTIVE || modeMain == MODE_SHINY}\n                                <PluginCombo\n                                    {...options}\n                                    isFlagged={modeMain == MODE_SHINY}\n                                    list={filterList(listX, [\"PLUGIN_MAIN\"])}\n                                    hidden={false}\n                                />\n                            {:else}\n                                <div class=\"statusnote\">{TITLES[modeMain]}</div>\n                            {/if}\n                        </div>\n                    </div>\n                    <div class=\"filerow {hideEven ? 'hideeven' : ''}\">\n                        <div class=\"filetitle\">\n                            <button\n                                class=\"status\"\n                                on:click={(evt) => askMode(evt, `${PREFIX_PLUGIN_DATA}/${name}`, bindKeyData)}\n                            >\n                                {getIcon(modeData)}\n                            </button>\n                            <span class=\"name\">DATA</span>\n                        </div>\n                        <div class=\"body\">\n                            {#if modeData == MODE_SELECTIVE || modeData == MODE_SHINY}\n                                <PluginCombo\n                                    {...options}\n                                    isFlagged={modeData == MODE_SHINY}\n                                    list={filterList(listX, [\"PLUGIN_DATA\"])}\n                                    hidden={false}\n                                />\n                            {:else}\n                                <div class=\"statusnote\">{TITLES[modeData]}</div>\n                            {/if}\n                        </div>\n                    </div>\n                    {#if useSyncPluginEtc}\n                        <div class=\"filerow {hideEven ? 'hideeven' : ''}\">\n                            <div class=\"filetitle\">\n                                <button\n                                    class=\"status\"\n                                    on:click={(evt) => askMode(evt, `${PREFIX_PLUGIN_ETC}/${name}`, bindKeyETC)}\n                                >\n                                    {getIcon(modeEtc)}\n                                </button>\n                                <span class=\"name\">Other files</span>\n                            </div>\n                            <div class=\"body\">\n                                {#if modeEtc == MODE_SELECTIVE || modeEtc == MODE_SHINY}\n                                    <PluginCombo\n                                        {...options}\n                                        isFlagged={modeEtc == MODE_SHINY}\n                                        list={filterList(listX, [\"PLUGIN_ETC\"])}\n                                        hidden={false}\n                                    />\n                                {:else}\n                                    <div class=\"statusnote\">{TITLES[modeEtc]}</div>\n                                {/if}\n                            </div>\n                        </div>\n                    {/if}\n                {:else}\n                    <div class=\"noterow\">\n                        <div class=\"statusnote\">{TITLES[modeAll]}</div>\n                    </div>\n                {/if}\n            {/each}\n        </div>\n    {/if}\n</div>\n{#if isMaintenanceMode}\n    <div class=\"buttons\">\n        <div>\n            <h3>Maintenance Commands</h3>\n            <div class=\"maintenancerow\">\n                <label for=\"\">Delete All of </label>\n                <select bind:value={deleteTerm}>\n                    {#each allTerms as term}\n                        <option value={term}>{term}</option>\n                    {/each}\n                </select>\n                <button\n                    class=\"status\"\n                    on:click={(evt) => {\n                        deleteAllItems(deleteTerm);\n                    }}\n                >\n                    üóëÔ∏è\n                </button>\n            </div>\n        </div>\n    </div>\n{/if}\n<div class=\"buttons\">\n    <label><span>Hide not applicable items</span><input type=\"checkbox\" bind:checked={hideEven} /></label>\n</div>\n<div class=\"buttons\">\n    <label><span>Maintenance mode</span><input type=\"checkbox\" bind:checked={isMaintenanceMode} /></label>\n</div>\n\n<style>\n    .buttonsWrap {\n        padding-bottom: 4px;\n    }\n    h3 {\n        position: sticky;\n        top: 0;\n        background-color: var(--modal-background);\n    }\n    .labelrow {\n        margin-left: 0.4em;\n        display: flex;\n        justify-content: flex-start;\n        align-items: center;\n        border-top: 1px solid var(--background-modifier-border);\n        padding: 4px;\n        flex-wrap: wrap;\n    }\n    .filerow {\n        margin-left: 1.25em;\n        display: flex;\n        justify-content: flex-start;\n        align-items: center;\n        padding-right: 4px;\n        flex-wrap: wrap;\n    }\n\n    .filerow.hideeven:has(:global(.even)),\n    .labelrow.hideeven:has(:global(.even)) {\n        display: none;\n    }\n\n    .noterow {\n        min-height: 2em;\n        display: flex;\n    }\n    button.status {\n        flex-grow: 0;\n        margin: 2px 4px;\n        min-width: 3em;\n        max-width: 4em;\n    }\n    .statusnote {\n        display: flex;\n        justify-content: flex-end;\n        padding-right: var(--size-4-12);\n        align-items: center;\n        min-width: 10em;\n        flex-grow: 1;\n    }\n    .list {\n        overflow-y: auto;\n    }\n    .title {\n        color: var(--text-normal);\n        font-size: var(--font-ui-medium);\n        line-height: var(--line-height-tight);\n        margin-right: auto;\n    }\n    .body {\n        /* margin-left: 0.4em; */\n        margin-left: auto;\n        display: flex;\n        justify-content: flex-start;\n        align-items: center;\n        /* flex-wrap: wrap; */\n    }\n    .filetitle {\n        color: var(--text-normal);\n        font-size: var(--font-ui-medium);\n        line-height: var(--line-height-tight);\n        margin-right: auto;\n    }\n    .buttons {\n        display: flex;\n        flex-direction: row;\n        justify-content: flex-end;\n        margin-top: 8px;\n        flex-wrap: wrap;\n    }\n    .buttons > button {\n        margin-left: 4px;\n        width: auto;\n    }\n\n    label {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n    }\n    label > span {\n        margin-right: 0.25em;\n    }\n    :global(.is-mobile) .title,\n    :global(.is-mobile) .filetitle {\n        width: 100%;\n    }\n\n    .center {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        min-height: 3em;\n    }\n    .maintenancerow {\n        display: flex;\n        justify-content: flex-end;\n        align-items: center;\n    }\n    .maintenancerow label {\n        margin-right: 0.5em;\n        margin-left: 0.5em;\n    }\n\n    .loading {\n        transition: height 0.25s ease-in-out;\n        transition-delay: 4ms;\n        overflow-y: hidden;\n        flex-shrink: 0;\n        display: flex;\n        justify-content: flex-start;\n        align-items: center;\n    }\n    .loading:empty {\n        height: 0px;\n        transition: height 0.25s ease-in-out;\n        transition-delay: 1s;\n    }\n    .loading:not(:empty) {\n        height: 2em;\n        transition: height 0.25s ease-in-out;\n        transition-delay: 0;\n    }\n</style>\n", "<script lang=\"ts\">import { onDestroy, onMount } from \"svelte\";\nimport { perf_trench } from \"./tests.ts\";\nimport { MarkdownRenderer, Notice } from \"../../../deps.ts\";\nimport { fireAndForget } from \"octagonal-wheels/promises\";\nimport { EVENT_LAYOUT_READY, eventHub } from \"../../../common/events.ts\";\nimport { writable } from \"svelte/store\";\nexport let plugin;\nexport let moduleDev;\nlet performanceTestResult = \"\";\nlet functionCheckResult = \"\";\nlet testRunning = false;\nlet prefTestResultEl;\nlet isReady = false;\n$: {\n    if (performanceTestResult != \"\" && isReady) {\n        MarkdownRenderer.render(plugin.app, performanceTestResult, prefTestResultEl, \"/\", plugin);\n    }\n}\nasync function performTest() {\n    try {\n        testRunning = true;\n        performanceTestResult = await perf_trench(plugin);\n    }\n    finally {\n        testRunning = false;\n    }\n}\nfunction clearResult() {\n    moduleDev.testResults.update((v) => {\n        v = [];\n        return v;\n    });\n}\nfunction clearPerfTestResult() {\n    prefTestResultEl.empty();\n}\nonMount(async () => {\n    isReady = true;\n    // performTest();\n    eventHub.onceEvent(EVENT_LAYOUT_READY, async () => {\n        if (await plugin.storageAccess.isExistsIncludeHidden(\"_AUTO_TEST.md\")) {\n            new Notice(\"Auto test file found, running tests...\");\n            fireAndForget(async () => {\n                await allTest();\n            });\n        }\n        else {\n            // new Notice(\"No auto test file found, skipping tests...\");\n        }\n    });\n});\nlet moduleTesting = false;\nfunction moduleMultiDeviceTest() {\n    if (moduleTesting)\n        return;\n    moduleTesting = true;\n    plugin.services.test.testMultiDevice().finally(() => {\n        moduleTesting = false;\n    });\n}\nfunction moduleSingleDeviceTest() {\n    if (moduleTesting)\n        return;\n    moduleTesting = true;\n    plugin.services.test.test().finally(() => {\n        moduleTesting = false;\n    });\n}\nasync function allTest() {\n    if (moduleTesting)\n        return;\n    moduleTesting = true;\n    try {\n        await plugin.services.test.test();\n        await plugin.services.test.testMultiDevice();\n    }\n    finally {\n        moduleTesting = false;\n    }\n}\nconst results = moduleDev.testResults;\n$: resultLines = $results;\nlet syncStatus = [];\neventHub.onEvent(\"debug-sync-status\", (status) => {\n    syncStatus = [...status];\n});\n</script>\n\n<h2>TESTING BENCH: Self-hosted LiveSync</h2>\n\n<h3>Module Checks</h3>\n<button on:click={() => moduleMultiDeviceTest()} disabled={moduleTesting}>MultiDevice Test</button>\n<button on:click={() => moduleSingleDeviceTest()} disabled={moduleTesting}>SingleDevice Test</button>\n<button on:click={() => allTest()} disabled={moduleTesting}>All Test</button>\n<button on:click={() => clearResult()}>Clear</button>\n\n{#each resultLines as [result, line, message]}\n    <details open={!result}>\n        <summary>[{result ? \"PASS\" : \"FAILED\"}] {line}</summary>\n        <pre>{message}</pre>\n    </details>\n{/each}\n\n<h3>Synchronisation Result Status</h3>\n<pre>{syncStatus.join(\"\\n\")}</pre>\n\n<h3>Performance test</h3>\n<button on:click={() => performTest()} disabled={testRunning}>Test!</button>\n<button on:click={() => clearPerfTestResult()}>Clear</button>\n\n<div bind:this={prefTestResultEl}></div>\n\n<style>\n    * {\n        box-sizing: border-box;\n    }\n</style>\n", "<script lang=\"ts\">import ObsidianLiveSyncPlugin from \"../../../main.ts\";\nimport { onDestroy, onMount } from \"svelte\";\nimport { getDocData, isAnyNote, isDocContentSame, readAsBlob } from \"../../../lib/src/common/utils.ts\";\nimport { diff_match_patch } from \"../../../deps.ts\";\nimport { DocumentHistoryModal } from \"../DocumentHistory/DocumentHistoryModal.ts\";\nimport { isPlainText, stripAllPrefixes } from \"../../../lib/src/string_and_binary/path.ts\";\nimport { getPath } from \"../../../common/utils.ts\";\nexport let plugin;\nlet showDiffInfo = false;\nlet showChunkCorrected = false;\nlet checkStorageDiff = false;\nlet range_from_epoch = Date.now() - 3600000 * 24 * 7;\nlet range_to_epoch = Date.now() + 3600000 * 24 * 2;\nconst timezoneOffset = new Date().getTimezoneOffset();\nlet dispDateFrom = new Date(range_from_epoch - timezoneOffset).toISOString().split(\"T\")[0];\nlet dispDateTo = new Date(range_to_epoch - timezoneOffset).toISOString().split(\"T\")[0];\n$: {\n    range_from_epoch = new Date(dispDateFrom).getTime() + timezoneOffset;\n    range_to_epoch = new Date(dispDateTo).getTime() + timezoneOffset;\n    getHistory(showDiffInfo, showChunkCorrected, checkStorageDiff);\n}\nfunction mtimeToDate(mtime) {\n    return new Date(mtime).toLocaleString();\n}\nlet history = [];\nlet loading = false;\nasync function fetchChanges() {\n    var _a, _b, _c;\n    try {\n        const db = plugin.localDatabase;\n        let result = [];\n        for await (const docA of db.findAllNormalDocs()) {\n            if (docA.mtime < range_from_epoch) {\n                continue;\n            }\n            if (!isAnyNote(docA))\n                continue;\n            const path = getPath(docA);\n            const isPlain = isPlainText(docA.path);\n            const revs = await db.getRaw(docA._id, { revs_info: true });\n            let p = undefined;\n            const reversedRevs = ((_a = revs._revs_info) !== null && _a !== void 0 ? _a : []).reverse();\n            const DIFF_DELETE = -1;\n            const DIFF_EQUAL = 0;\n            const DIFF_INSERT = 1;\n            for (const revInfo of reversedRevs) {\n                if (revInfo.status == \"available\") {\n                    const doc = (!isPlain && showDiffInfo) || (checkStorageDiff && revInfo.rev == docA._rev)\n                        ? await db.getDBEntry(path, { rev: revInfo.rev }, false, false, true)\n                        : await db.getDBEntryMeta(path, { rev: revInfo.rev }, true);\n                    if (doc === false)\n                        continue;\n                    const rev = revInfo.rev;\n                    const mtime = \"mtime\" in doc ? doc.mtime : 0;\n                    if (range_from_epoch > mtime) {\n                        continue;\n                    }\n                    if (range_to_epoch < mtime) {\n                        continue;\n                    }\n                    let diffDetail = \"\";\n                    if (showDiffInfo && !isPlain) {\n                        const data = getDocData(doc.data);\n                        if (p === undefined) {\n                            p = data;\n                        }\n                        if (p != data) {\n                            const dmp = new diff_match_patch();\n                            const diff = dmp.diff_main(p, data);\n                            dmp.diff_cleanupSemantic(diff);\n                            p = data;\n                            const pxInit = {\n                                [DIFF_DELETE]: 0,\n                                [DIFF_EQUAL]: 0,\n                                [DIFF_INSERT]: 0,\n                            };\n                            const px = diff.reduce((p, c) => { var _a; return ({ ...p, [c[0]]: ((_a = p[c[0]]) !== null && _a !== void 0 ? _a : 0) + c[1].length }); }, pxInit);\n                            diffDetail = `-${px[DIFF_DELETE]}, +${px[DIFF_INSERT]}`;\n                        }\n                    }\n                    const isDeleted = doc._deleted || (doc === null || doc === void 0 ? void 0 : doc.deleted) || false;\n                    if (isDeleted) {\n                        diffDetail += \" üóëÔ∏è\";\n                    }\n                    if (rev == docA._rev) {\n                        if (checkStorageDiff) {\n                            const isExist = await plugin.storageAccess.isExistsIncludeHidden(stripAllPrefixes(getPath(docA)));\n                            if (isExist) {\n                                const data = await plugin.storageAccess.readHiddenFileBinary(stripAllPrefixes(getPath(docA)));\n                                const d = readAsBlob(doc);\n                                const result = await isDocContentSame(data, d);\n                                if (result) {\n                                    diffDetail += \" ‚öñÔ∏è\";\n                                }\n                                else {\n                                    diffDetail += \" ‚ö†Ô∏è\";\n                                }\n                            }\n                        }\n                    }\n                    const docPath = getPath(doc);\n                    const [filename, ...pathItems] = docPath.split(\"/\").reverse();\n                    let chunksStatus = \"\";\n                    if (showChunkCorrected) {\n                        const chunks = (_b = doc === null || doc === void 0 ? void 0 : doc.children) !== null && _b !== void 0 ? _b : [];\n                        const loadedChunks = await db.allDocsRaw({ keys: [...chunks] });\n                        const totalCount = loadedChunks.rows.length;\n                        const errorCount = loadedChunks.rows.filter((e) => \"error\" in e).length;\n                        if (errorCount == 0) {\n                            chunksStatus = `‚úÖ ${totalCount}`;\n                        }\n                        else {\n                            chunksStatus = `üîé ${errorCount} ‚úÖ ${totalCount}`;\n                        }\n                    }\n                    result.push({\n                        id: doc._id,\n                        rev: doc._rev,\n                        path: docPath,\n                        dirname: pathItems.reverse().join(\"/\"),\n                        filename: filename,\n                        mtime: mtime,\n                        mtimeDisp: mtimeToDate(mtime),\n                        size: (_c = doc === null || doc === void 0 ? void 0 : doc.size) !== null && _c !== void 0 ? _c : 0,\n                        isDeleted: isDeleted,\n                        changes: diffDetail,\n                        chunks: chunksStatus,\n                        isPlain: isPlain,\n                    });\n                }\n            }\n        }\n        return [...result].sort((a, b) => b.mtime - a.mtime);\n    }\n    finally {\n        loading = false;\n    }\n}\nasync function getHistory(showDiffInfo, showChunkCorrected, checkStorageDiff) {\n    loading = true;\n    const newDisplay = [];\n    const page = await fetchChanges();\n    newDisplay.push(...page);\n    history = [...newDisplay];\n}\nfunction nextWeek() {\n    dispDateTo = new Date(range_to_epoch - timezoneOffset + 3600 * 1000 * 24 * 7).toISOString().split(\"T\")[0];\n}\nfunction prevWeek() {\n    dispDateFrom = new Date(range_from_epoch - timezoneOffset - 3600 * 1000 * 24 * 7).toISOString().split(\"T\")[0];\n}\nonMount(async () => {\n    await getHistory(showDiffInfo, showChunkCorrected, checkStorageDiff);\n});\nonDestroy(() => { });\nfunction showHistory(file, rev) {\n    new DocumentHistoryModal(plugin.app, plugin, file, undefined, rev).open();\n}\nfunction openFile(file) {\n    plugin.app.workspace.openLinkText(file, file);\n}\n</script>\n\n<div class=\"globalhistory\">\n    <h1>Vault history</h1>\n    <div class=\"control\">\n        <div class=\"row\">\n            <label for=\"\">From:</label><input type=\"date\" bind:value={dispDateFrom} disabled={loading} />\n        </div>\n        <div class=\"row\"><label for=\"\">To:</label><input type=\"date\" bind:value={dispDateTo} disabled={loading} /></div>\n        <div class=\"row\">\n            <label for=\"\">Info:</label>\n            <label><input type=\"checkbox\" bind:checked={showDiffInfo} disabled={loading} /><span>Diff</span></label>\n            <label\n                ><input type=\"checkbox\" bind:checked={showChunkCorrected} disabled={loading} /><span>Chunks</span\n                ></label\n            >\n            <label\n                ><input type=\"checkbox\" bind:checked={checkStorageDiff} disabled={loading} /><span>File integrity</span\n                ></label\n            >\n        </div>\n    </div>\n    {#if loading}\n        <div class=\"\">Gathering information...</div>\n    {/if}\n    <table>\n        <tbody>\n        <tr>\n            <th> Date </th>\n            <th> Path </th>\n            <th> Rev </th>\n            <th> Stat </th>\n            {#if showChunkCorrected}\n                <th> Chunks </th>\n            {/if}\n        </tr>\n        <tr>\n            <td colspan=\"5\" class=\"more\">\n                {#if loading}\n                        <div class=\"\"></div>\n                {:else}\n                    <div><button on:click={() => nextWeek()}>+1 week</button></div>\n                {/if}\n            </td>\n        </tr>\n        {#each history as entry}\n            <tr>\n                <td class=\"mtime\">\n                    {entry.mtimeDisp}\n                </td>\n                <td class=\"path\">\n                    <div class=\"filenames\">\n                        <span class=\"path\">/{entry.dirname.split(\"/\").join(`‚Äã/`)}</span>\n                        <!-- svelte-ignore a11y-click-events-have-key-events -->\n                        <!-- svelte-ignore a11y-no-static-element-interactions -->\n                        <!-- svelte-ignore a11y-missing-attribute -->\n                        <span class=\"filename\"><a on:click={() => openFile(entry.path)}>{entry.filename}</a></span>\n                    </div>\n                </td>\n                <td>\n                    <span class=\"rev\">\n                        {#if entry.isPlain}\n                            <!-- svelte-ignore a11y-click-events-have-key-events -->\n                            <!-- svelte-ignore a11y-no-static-element-interactions -->\n                            <!-- svelte-ignore a11y-missing-attribute -->\n                            <a on:click={() => showHistory(entry.path, entry?.rev || \"\")}>{entry.rev}</a>\n                        {:else}\n                            {entry.rev}\n                        {/if}\n                    </span>\n                </td>\n                <td>\n                    {entry.changes}\n                </td>\n                {#if showChunkCorrected}\n                    <td>\n                        {entry.chunks}\n                    </td>\n                {/if}\n            </tr>\n        {/each}\n        <tr>\n            <td colspan=\"5\" class=\"more\">\n                {#if loading}\n                        <div class=\"\"></div>\n                {:else}\n                    <div><button on:click={() => prevWeek()}>+1 week</button></div>\n                {/if}\n            </td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n\n<style>\n    * {\n        box-sizing: border-box;\n    }\n    .globalhistory {\n        margin-bottom: 2em;\n    }\n    table {\n        width: 100%;\n    }\n    .more > div {\n        display: flex;\n    }\n    .more > div > button {\n        flex-grow: 1;\n    }\n    th {\n        position: sticky;\n        top: 0;\n        backdrop-filter: blur(10px);\n    }\n    td.mtime {\n        white-space: break-spaces;\n    }\n    td.path {\n        word-break: break-word;\n    }\n    .row {\n        display: flex;\n        flex-direction: row;\n        flex-wrap: wrap;\n    }\n    .row > label {\n        display: flex;\n        align-items: center;\n        min-width: 5em;\n    }\n    .row > input {\n        flex-grow: 1;\n    }\n\n    .filenames {\n        display: flex;\n        flex-direction: column;\n    }\n    .filenames > .path {\n        font-size: 70%;\n    }\n    .rev {\n        text-overflow: ellipsis;\n        max-width: 3em;\n        display: inline-block;\n        overflow: hidden;\n        white-space: nowrap;\n    }\n</style>\n", "<script lang=\"ts\">import { getContext } from \"svelte\";\nimport { AcceptedStatus } from \"../../../lib/src/replication/trystero/P2PReplicatorPaneCommon\";\nimport { eventHub } from \"../../../common/events\";\nimport { EVENT_P2P_PEER_SHOW_EXTRA_MENU } from \"../../../lib/src/replication/trystero/P2PReplicatorPaneCommon\";\nlet { peerStatus } = $props();\nlet peer = $derived(peerStatus);\nfunction select(d, cond, def) {\n    return d in cond ? cond[d] : def;\n}\nlet statusChips = $derived.by(() => [\n    peer.isWatching ? [\"WATCHING\"] : [],\n    peer.isFetching ? [\"FETCHING\"] : [],\n    peer.isSending ? [\"SENDING\"] : [],\n].flat());\nlet acceptedStatusChip = $derived.by(() => select(peer.accepted.toString(), {\n    [AcceptedStatus.ACCEPTED]: \"ACCEPTED\",\n    [AcceptedStatus.ACCEPTED_IN_SESSION]: \"ACCEPTED (in session)\",\n    [AcceptedStatus.DENIED_IN_SESSION]: \"DENIED (in session)\",\n    [AcceptedStatus.DENIED]: \"DENIED\",\n    [AcceptedStatus.UNKNOWN]: \"NEW\",\n}, \"\"));\nconst classList = {\n    [\"SENDING\"]: \"connected\",\n    [\"FETCHING\"]: \"connected\",\n    [\"WATCHING\"]: \"connected-live\",\n    [\"WAITING\"]: \"waiting\",\n    [\"ACCEPTED\"]: \"accepted\",\n    [\"DENIED\"]: \"denied\",\n    [\"NEW\"]: \"unknown\",\n};\nlet isAccepted = $derived.by(() => peer.accepted === AcceptedStatus.ACCEPTED || peer.accepted === AcceptedStatus.ACCEPTED_IN_SESSION);\nlet isDenied = $derived.by(() => peer.accepted === AcceptedStatus.DENIED || peer.accepted === AcceptedStatus.DENIED_IN_SESSION);\nlet isNew = $derived.by(() => peer.accepted === AcceptedStatus.UNKNOWN);\nfunction makeDecision(isAccepted, isTemporary) {\n    var _a, _b;\n    (_b = (_a = cmdReplicator._replicatorInstance) === null || _a === void 0 ? void 0 : _a.server) === null || _b === void 0 ? void 0 : _b.makeDecision({\n        peerId: peer.peerId,\n        name: peer.name,\n        decision: isAccepted,\n        isTemporary: isTemporary,\n    });\n}\nfunction revokeDecision() {\n    var _a, _b;\n    (_b = (_a = cmdReplicator._replicatorInstance) === null || _a === void 0 ? void 0 : _a.server) === null || _b === void 0 ? void 0 : _b.revokeDecision({\n        peerId: peer.peerId,\n        name: peer.name,\n    });\n}\nconst cmdReplicator = getContext(\"getReplicator\")();\nconst replicator = cmdReplicator._replicatorInstance;\nconst peerAttrLabels = $derived.by(() => {\n    const attrs = [];\n    if (peer.syncOnConnect) {\n        attrs.push(\"‚úî SYNC\");\n    }\n    if (peer.watchOnConnect) {\n        attrs.push(\"‚úî WATCH\");\n    }\n    if (peer.syncOnReplicationCommand) {\n        attrs.push(\"‚úî SELECT\");\n    }\n    return attrs;\n});\nfunction startWatching() {\n    replicator.watchPeer(peer.peerId);\n}\nfunction stopWatching() {\n    replicator.unwatchPeer(peer.peerId);\n}\nfunction sync() {\n    replicator.sync(peer.peerId, false);\n}\nfunction moreMenu(evt) {\n    eventHub.emitEvent(EVENT_P2P_PEER_SHOW_EXTRA_MENU, { peer, event: evt });\n}\n</script>\n\n<tr>\n    <td>\n        <div class=\"info\">\n            <div class=\"row name\">\n                <span class=\"peername\">{peer.name}</span>\n            </div>\n            <div class=\"row peer-id\">\n                <span class=\"peerid\">({peer.peerId})</span>\n            </div>\n        </div>\n        <div class=\"status-chips\">\n            <div class=\"row\">\n                <span class=\"chip {select(acceptedStatusChip, classList)}\">{acceptedStatusChip}</span>\n            </div>\n            {#if isAccepted}\n                <div class=\"row\">\n                    {#each statusChips as chip}\n                        <span class=\"chip {select(chip, classList)}\">{chip}</span>\n                    {/each}\n                </div>\n            {/if}\n            <div class=\"row\">\n                {#each peerAttrLabels as attr}\n                    <span class=\"chip attr\">{attr}</span>\n                {/each}\n            </div>\n        </div>\n    </td>\n    <td>\n        <div class=\"buttons\">\n            <div class=\"row\">\n                {#if isNew}\n                    {#if !isAccepted}\n                        <button class=\"button\" onclick={() => makeDecision(true, true)}>Accept in session</button>\n                        <button class=\"button mod-cta\" onclick={() => makeDecision(true, false)}>Accept</button>\n                    {/if}\n                    {#if !isDenied}\n                        <button class=\"button\" onclick={() => makeDecision(false, true)}>Deny in session</button>\n                        <button class=\"button mod-warning\" onclick={() => makeDecision(false, false)}>Deny</button>\n                    {/if}\n                {:else}\n                    <button class=\"button mod-warning\" onclick={() => revokeDecision()}>Revoke</button>\n                {/if}\n            </div>\n        </div>\n    </td>\n    <td>\n        {#if isAccepted}\n            <div class=\"buttons\">\n                <div class=\"row\">\n                    <button class=\"button\" onclick={sync} disabled={peer.isSending || peer.isFetching}>üîÑ</button>\n                    <!-- <button class=\"button\" onclick={replicateFrom} disabled={peer.isFetching}>üì•</button>\n                    <button class=\"button\" onclick={replicateTo} disabled={peer.isSending}>üì§</button> -->\n                    {#if peer.isWatching}\n                        <button class=\"button\" onclick={stopWatching}>Stop ‚ö°</button>\n                    {:else}\n                        <button class=\"button\" onclick={startWatching} title=\"live\">‚ö°</button>\n                    {/if}\n                    <button class=\"button\" onclick={moreMenu}>...</button>\n                </div>\n            </div>\n        {/if}\n    </td>\n</tr>\n\n<style>\n    tr:nth-child(odd) {\n        background-color: var(--background-primary-alt);\n    }\n    .info {\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        padding: var(--size-4-1) var(--size-4-1);\n    }\n\n    .peer-id {\n        font-size: 0.8em;\n    }\n    .status-chips {\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        /* min-width: 10em; */\n    }\n    .buttons {\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n    }\n    .buttons .row {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        flex-wrap: wrap;\n        /* padding: var(--size-4-1) var(--size-4-1); */\n    }\n    .chip {\n        display: inline-block;\n        padding: 4px 8px;\n        margin: 4px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        font-weight: bold;\n        background-color: var(--tag-background);\n        border: var(--tag-border-width) solid var(--tag-border-color);\n    }\n    .chip.connected {\n        background-color: var(--background-modifier-success);\n        color: var(--text-normal);\n    }\n    .chip.connected-live {\n        background-color: var(--background-modifier-success);\n        border-color: var(--background-modifier-success);\n        color: var(--text-normal);\n    }\n    .chip.accepted {\n        background-color: var(--background-modifier-success);\n        color: var(--text-normal);\n    }\n    .chip.waiting {\n        background-color: var(--background-secondary);\n    }\n    .chip.unknown {\n        background-color: var(--background-primary);\n        color: var(--text-warning);\n    }\n    .chip.denied {\n        background-color: var(--background-modifier-error);\n        color: var(--text-error);\n    }\n    .chip.attr {\n        background-color: var(--background-secondary);\n    }\n    .button {\n        margin: var(--size-4-1);\n    }\n    .button.affirmative {\n        background-color: var(--interactive-accent);\n        color: var(--text-normal);\n    }\n    .button.affirmative:hover {\n        background-color: var(--interactive-accent-hover);\n    }\n    .button.negative {\n        background-color: var(--background-modifier-error);\n        color: var(--text-error);\n    }\n    .button.negative:hover {\n        background-color: var(--background-modifier-error-hover);\n    }\n</style>\n", "<script lang=\"ts\">var _a, _b, _c;\nimport { onMount, setContext } from \"svelte\";\nimport { AutoAccepting, DEFAULT_SETTINGS } from \"../../../lib/src/common/types\";\nimport { AcceptedStatus, ConnectionStatus, } from \"../../../lib/src/replication/trystero/P2PReplicatorPaneCommon\";\nimport PeerStatusRow from \"../P2PReplicator/PeerStatusRow.svelte\";\nimport { EVENT_LAYOUT_READY, eventHub } from \"../../../common/events\";\nimport { EVENT_SERVER_STATUS, EVENT_REQUEST_STATUS, EVENT_P2P_REPLICATOR_STATUS, } from \"../../../lib/src/replication/trystero/TrysteroReplicatorP2PServer\";\nimport {} from \"../../../lib/src/replication/trystero/TrysteroReplicator\";\nimport { $msg as _msg } from \"../../../lib/src/common/i18n\";\nimport { SETTING_KEY_P2P_DEVICE_NAME } from \"../../../lib/src/common/types\";\nlet { plugin, cmdSync } = $props();\n// const cmdSync = plugin.getAddOn<P2PReplicator>(\"P2PReplicator\")!;\nsetContext(\"getReplicator\", () => cmdSync);\nconst initialSettings = { ...plugin.settings };\nlet settings = $state(initialSettings);\n// const vaultName = service.vault.getVaultName();\n// const dbKey = `${vaultName}-p2p-device-name`;\nconst initialDeviceName = (_a = cmdSync.getConfig(SETTING_KEY_P2P_DEVICE_NAME)) !== null && _a !== void 0 ? _a : plugin.services.vault.getVaultName();\nlet deviceName = $state(initialDeviceName);\nlet eP2PEnabled = $state(initialSettings.P2P_Enabled);\nlet eRelay = $state(initialSettings.P2P_relays);\nlet eRoomId = $state(initialSettings.P2P_roomID);\nlet ePassword = $state(initialSettings.P2P_passphrase);\nlet eAppId = $state(initialSettings.P2P_AppID);\nlet eDeviceName = $state(initialDeviceName);\nlet eAutoAccept = $state(initialSettings.P2P_AutoAccepting == AutoAccepting.ALL);\nlet eAutoStart = $state(initialSettings.P2P_AutoStart);\nlet eAutoBroadcast = $state(initialSettings.P2P_AutoBroadcast);\nconst isP2PEnabledModified = $derived.by(() => eP2PEnabled !== settings.P2P_Enabled);\nconst isRelayModified = $derived.by(() => eRelay !== settings.P2P_relays);\nconst isRoomIdModified = $derived.by(() => eRoomId !== settings.P2P_roomID);\nconst isPasswordModified = $derived.by(() => ePassword !== settings.P2P_passphrase);\nconst isAppIdModified = $derived.by(() => eAppId !== settings.P2P_AppID);\nconst isDeviceNameModified = $derived.by(() => eDeviceName !== deviceName);\nconst isAutoAcceptModified = $derived.by(() => eAutoAccept !== (settings.P2P_AutoAccepting == AutoAccepting.ALL));\nconst isAutoStartModified = $derived.by(() => eAutoStart !== settings.P2P_AutoStart);\nconst isAutoBroadcastModified = $derived.by(() => eAutoBroadcast !== settings.P2P_AutoBroadcast);\nconst isAnyModified = $derived.by(() => isP2PEnabledModified ||\n    isRelayModified ||\n    isRoomIdModified ||\n    isPasswordModified ||\n    isAppIdModified ||\n    isDeviceNameModified ||\n    isAutoAcceptModified ||\n    isAutoStartModified ||\n    isAutoBroadcastModified);\nasync function saveAndApply() {\n    const newSettings = {\n        ...plugin.settings,\n        P2P_Enabled: eP2PEnabled,\n        P2P_relays: eRelay,\n        P2P_roomID: eRoomId,\n        P2P_passphrase: ePassword,\n        P2P_AppID: eAppId,\n        P2P_AutoAccepting: eAutoAccept ? AutoAccepting.ALL : AutoAccepting.NONE,\n        P2P_AutoStart: eAutoStart,\n        P2P_AutoBroadcast: eAutoBroadcast,\n    };\n    plugin.settings = newSettings;\n    cmdSync.setConfig(SETTING_KEY_P2P_DEVICE_NAME, eDeviceName);\n    deviceName = eDeviceName;\n    await plugin.saveSettings();\n}\nasync function revert() {\n    eP2PEnabled = settings.P2P_Enabled;\n    eRelay = settings.P2P_relays;\n    eRoomId = settings.P2P_roomID;\n    ePassword = settings.P2P_passphrase;\n    eAppId = settings.P2P_AppID;\n    eAutoAccept = settings.P2P_AutoAccepting == AutoAccepting.ALL;\n    eAutoStart = settings.P2P_AutoStart;\n    eAutoBroadcast = settings.P2P_AutoBroadcast;\n}\nlet serverInfo = $state(undefined);\nlet replicatorInfo = $state(undefined);\nconst applyLoadSettings = (d, force) => {\n    const { P2P_relays, P2P_roomID, P2P_passphrase, P2P_AppID, P2P_AutoAccepting } = d;\n    if (force || !isP2PEnabledModified)\n        eP2PEnabled = d.P2P_Enabled;\n    if (force || !isRelayModified)\n        eRelay = P2P_relays;\n    if (force || !isRoomIdModified)\n        eRoomId = P2P_roomID;\n    if (force || !isPasswordModified)\n        ePassword = P2P_passphrase;\n    if (force || !isAppIdModified)\n        eAppId = P2P_AppID;\n    const newAutoAccept = P2P_AutoAccepting === AutoAccepting.ALL;\n    if (force || !isAutoAcceptModified)\n        eAutoAccept = newAutoAccept;\n    if (force || !isAutoStartModified)\n        eAutoStart = d.P2P_AutoStart;\n    if (force || !isAutoBroadcastModified)\n        eAutoBroadcast = d.P2P_AutoBroadcast;\n    settings = d;\n};\nonMount(() => {\n    const r = eventHub.onEvent(\"setting-saved\", async (d) => {\n        applyLoadSettings(d, false);\n        closeServer();\n    });\n    const rx = eventHub.onEvent(EVENT_LAYOUT_READY, () => {\n        applyLoadSettings(plugin.settings, true);\n    });\n    const r2 = eventHub.onEvent(EVENT_SERVER_STATUS, (status) => {\n        var _a;\n        serverInfo = status;\n        advertisements = (_a = status === null || status === void 0 ? void 0 : status.knownAdvertisements) !== null && _a !== void 0 ? _a : [];\n    });\n    const r3 = eventHub.onEvent(EVENT_P2P_REPLICATOR_STATUS, (status) => {\n        replicatorInfo = status;\n    });\n    eventHub.emitEvent(EVENT_REQUEST_STATUS);\n    return () => {\n        r();\n        r2();\n        r3();\n    };\n});\nlet isConnected = $derived.by(() => {\n    var _a;\n    return (_a = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.isConnected) !== null && _a !== void 0 ? _a : false;\n});\nlet serverPeerId = $derived.by(() => {\n    var _a;\n    return (_a = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.serverPeerId) !== null && _a !== void 0 ? _a : \"\";\n});\nlet advertisements = $state([]);\nlet autoSyncPeers = $derived.by(() => settings.P2P_AutoSyncPeers.split(\",\")\n    .map((e) => e.trim())\n    .filter((e) => e));\nlet autoWatchPeers = $derived.by(() => settings.P2P_AutoWatchPeers.split(\",\")\n    .map((e) => e.trim())\n    .filter((e) => e));\nlet syncOnCommand = $derived.by(() => settings.P2P_SyncOnReplication.split(\",\")\n    .map((e) => e.trim())\n    .filter((e) => e));\nconst peers = $derived.by(() => advertisements.map((ad) => {\n    let accepted;\n    const isTemporaryAccepted = ad.isTemporaryAccepted;\n    if (isTemporaryAccepted === undefined) {\n        if (ad.isAccepted === undefined) {\n            accepted = AcceptedStatus.UNKNOWN;\n        }\n        else {\n            accepted = ad.isAccepted ? AcceptedStatus.ACCEPTED : AcceptedStatus.DENIED;\n        }\n    }\n    else if (isTemporaryAccepted === true) {\n        accepted = AcceptedStatus.ACCEPTED_IN_SESSION;\n    }\n    else {\n        accepted = AcceptedStatus.DENIED_IN_SESSION;\n    }\n    const isFetching = (replicatorInfo === null || replicatorInfo === void 0 ? void 0 : replicatorInfo.replicatingFrom.indexOf(ad.peerId)) !== -1;\n    const isSending = (replicatorInfo === null || replicatorInfo === void 0 ? void 0 : replicatorInfo.replicatingTo.indexOf(ad.peerId)) !== -1;\n    const isWatching = (replicatorInfo === null || replicatorInfo === void 0 ? void 0 : replicatorInfo.watchingPeers.indexOf(ad.peerId)) !== -1;\n    const syncOnStart = autoSyncPeers.indexOf(ad.name) !== -1;\n    const watchOnStart = autoWatchPeers.indexOf(ad.name) !== -1;\n    const syncOnReplicationCommand = syncOnCommand.indexOf(ad.name) !== -1;\n    const st = {\n        name: ad.name,\n        peerId: ad.peerId,\n        accepted: accepted,\n        status: ad.isAccepted ? ConnectionStatus.CONNECTED : ConnectionStatus.DISCONNECTED,\n        isSending: isSending,\n        isFetching: isFetching,\n        isWatching: isWatching,\n        syncOnConnect: syncOnStart,\n        watchOnConnect: watchOnStart,\n        syncOnReplicationCommand: syncOnReplicationCommand,\n    };\n    return st;\n}));\nfunction useDefaultRelay() {\n    eRelay = DEFAULT_SETTINGS.P2P_relays;\n}\nfunction _generateRandom() {\n    return (Math.floor(Math.random() * 1000) + 1000).toString().substring(1);\n}\nfunction generateRandom(length) {\n    let buf = \"\";\n    while (buf.length < length) {\n        buf += \"-\" + _generateRandom();\n    }\n    return buf.substring(1, length);\n}\nfunction chooseRandom() {\n    eRoomId = generateRandom(12) + \"-\" + Math.random().toString(36).substring(2, 5);\n}\nasync function openServer() {\n    await cmdSync.open();\n}\nasync function closeServer() {\n    await cmdSync.close();\n}\nfunction startBroadcasting() {\n    void cmdSync.enableBroadcastCastings();\n}\nfunction stopBroadcasting() {\n    void cmdSync.disableBroadcastCastings();\n}\nconst initialDialogStatusKey = `p2p-dialog-status`;\nconst getDialogStatus = () => {\n    var _a;\n    try {\n        const initialDialogStatus = JSON.parse((_a = cmdSync.getConfig(initialDialogStatusKey)) !== null && _a !== void 0 ? _a : \"{}\");\n        return initialDialogStatus;\n    }\n    catch (e) {\n        return {};\n    }\n};\nconst initialDialogStatus = getDialogStatus();\nlet isNoticeOpened = $state((_b = initialDialogStatus.notice) !== null && _b !== void 0 ? _b : true);\nlet isSettingOpened = $state((_c = initialDialogStatus.setting) !== null && _c !== void 0 ? _c : true);\n$effect(() => {\n    const dialogStatus = {\n        notice: isNoticeOpened,\n        setting: isSettingOpened,\n    };\n    cmdSync.setConfig(initialDialogStatusKey, JSON.stringify(dialogStatus));\n});\nlet isObsidian = $derived.by(() => {\n    return plugin.services.API.getPlatform() === \"obsidian\";\n});\n</script>\n\n<article>\n    <h1>Peer to Peer Replicator</h1>\n    <details bind:open={isNoticeOpened}>\n        <summary>{_msg(\"P2P.Note.Summary\")}</summary>\n        <p class=\"important\">{_msg(\"P2P.Note.important_note\")}</p>\n        <p class=\"important-sub\">\n            {_msg(\"P2P.Note.important_note_sub\")}\n        </p>\n        {#each _msg(\"P2P.Note.description\").split(\"\\n\\n\") as paragraph}\n            <p>{paragraph}</p>\n        {/each}\n    </details>\n    <h2>Connection Settings</h2>\n    {#if isObsidian}\n        You can configure in the Obsidian Plugin Settings.\n    {:else}\n        <details bind:open={isSettingOpened}>\n            <summary>{eRelay}</summary>\n            <table class=\"settings\">\n                <tbody>\n                    <tr>\n                        <th> Enable P2P Replicator </th>\n                        <td>\n                            <label class={{ \"is-dirty\": isP2PEnabledModified }}>\n                                <input type=\"checkbox\" bind:checked={eP2PEnabled} />\n                            </label>\n                        </td>\n                    </tr><tr>\n                        <th> Relay settings </th>\n                        <td>\n                            <label class={{ \"is-dirty\": isRelayModified }}>\n                                <input\n                                    type=\"text\"\n                                    placeholder=\"wss://exp-relay.vrtmrz.net, wss://xxxxx\"\n                                    bind:value={eRelay}\n                                    autocomplete=\"off\"\n                                />\n                                <button onclick={() => useDefaultRelay()}> Use vrtmrz's relay </button>\n                            </label>\n                        </td>\n                    </tr>\n                    <tr>\n                        <th> Room ID </th>\n                        <td>\n                            <label class={{ \"is-dirty\": isRoomIdModified }}>\n                                <input\n                                    type=\"text\"\n                                    placeholder=\"anything-you-like\"\n                                    bind:value={eRoomId}\n                                    autocomplete=\"off\"\n                                    spellcheck=\"false\"\n                                    autocorrect=\"off\"\n                                />\n                                <button onclick={() => chooseRandom()}> Use Random Number </button>\n                            </label>\n                            <span>\n                                <small>\n                                    This can isolate your connections between devices. Use the same Room ID for the same\n                                    devices.</small\n                                >\n                            </span>\n                        </td>\n                    </tr>\n                    <tr>\n                        <th> Password </th>\n                        <td>\n                            <label class={{ \"is-dirty\": isPasswordModified }}>\n                                <input type=\"password\" placeholder=\"password\" bind:value={ePassword} />\n                            </label>\n                            <span>\n                                <small>\n                                    This password is used to encrypt the connection. Use something long enough.\n                                </small>\n                            </span>\n                        </td>\n                    </tr>\n                    <tr>\n                        <th> This device name </th>\n                        <td>\n                            <label class={{ \"is-dirty\": isDeviceNameModified }}>\n                                <input\n                                    type=\"text\"\n                                    placeholder=\"iphone-16\"\n                                    bind:value={eDeviceName}\n                                    autocomplete=\"off\"\n                                />\n                            </label>\n                            <span>\n                                <small>\n                                    Device name to identify the device. Please use shorter one for the stable peer\n                                    detection, i.e., \"iphone-16\" or \"macbook-2021\".\n                                </small>\n                            </span>\n                        </td>\n                    </tr>\n                    <tr>\n                        <th> Auto Connect </th>\n                        <td>\n                            <label class={{ \"is-dirty\": isAutoStartModified }}>\n                                <input type=\"checkbox\" bind:checked={eAutoStart} />\n                            </label>\n                        </td>\n                    </tr>\n                    <tr>\n                        <th> Start change-broadcasting on Connect </th>\n                        <td>\n                            <label class={{ \"is-dirty\": isAutoBroadcastModified }}>\n                                <input type=\"checkbox\" bind:checked={eAutoBroadcast} />\n                            </label>\n                        </td>\n                    </tr>\n                    <!-- <tr>\n                <th> Auto Accepting </th>\n                <td>\n                    <label class={{ \"is-dirty\": isAutoAcceptModified }}>\n                        <input type=\"checkbox\" bind:checked={eAutoAccept} />\n                    </label>\n                </td>\n            </tr> -->\n                </tbody>\n            </table>\n            <button disabled={!isAnyModified} class=\"button mod-cta\" onclick={saveAndApply}>Save and Apply</button>\n            <button disabled={!isAnyModified} class=\"button\" onclick={revert}>Revert changes</button>\n        </details>\n    {/if}\n\n    <div>\n        <h2>Signaling Server Connection</h2>\n        <div>\n            {#if !isConnected}\n                <p>No Connection</p>\n            {:else}\n                <p>Connected to Signaling Server (as Peer ID: {serverPeerId})</p>\n            {/if}\n        </div>\n        <div>\n            {#if !isConnected}\n                <button onclick={openServer}>Connect</button>\n            {:else}\n                <button onclick={closeServer}>Disconnect</button>\n                {#if replicatorInfo?.isBroadcasting !== undefined}\n                    {#if replicatorInfo?.isBroadcasting}\n                        <button onclick={stopBroadcasting}>Stop Broadcasting</button>\n                    {:else}\n                        <button onclick={startBroadcasting}>Start Broadcasting</button>\n                    {/if}\n                {/if}\n                <details>\n                    <summary>Broadcasting?</summary>\n                    <p>\n                        <small>\n                            If you want to use `LiveSync`, you should broadcast changes. All `watching` peers which\n                            detects this will start the replication for fetching. <br />\n                            However, This should not be enabled if you want to increase your secrecy more.\n                        </small>\n                    </p>\n                </details>\n            {/if}\n        </div>\n    </div>\n\n    <div>\n        <h2>Peers</h2>\n        <table class=\"peers\">\n            <thead>\n                <tr>\n                    <th>Name</th>\n                    <th>Action</th>\n                    <th>Command</th>\n                </tr>\n            </thead>\n            <tbody>\n                {#each peers as peer}\n                    <PeerStatusRow peerStatus={peer}></PeerStatusRow>\n                {/each}\n            </tbody>\n        </table>\n    </div>\n</article>\n\n<style>\n    article {\n        max-width: 100%;\n    }\n    article p {\n        user-select: text;\n        -webkit-user-select: text;\n    }\n    h2 {\n        margin-top: var(--size-4-1);\n        margin-bottom: var(--size-4-1);\n        padding-bottom: var(--size-4-1);\n        border-bottom: 1px solid var(--background-modifier-border);\n    }\n    label.is-dirty {\n        background-color: var(--background-modifier-error);\n    }\n    input {\n        background-color: transparent;\n    }\n    th {\n        /* display: flex;\n        justify-content: center;\n        align-items: center; */\n        min-height: var(--input-height);\n    }\n    td {\n        min-height: var(--input-height);\n    }\n    td > label {\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n        justify-content: flex-start;\n        min-height: var(--input-height);\n    }\n    td > label > * {\n        margin: auto var(--size-4-1);\n    }\n    table.peers {\n        width: 100%;\n    }\n    .important {\n        color: var(--text-error);\n        font-size: 1.2em;\n        font-weight: bold;\n    }\n    .important-sub {\n        color: var(--text-warning);\n    }\n    .settings label {\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n        justify-content: flex-start;\n        flex-wrap: wrap;\n    }\n</style>\n", "<script lang=\"ts\">import { onMount } from \"svelte\";\nimport DialogHeader from \"../components/DialogHeader.svelte\";\nimport Instruction from \"../components/Instruction.svelte\";\nimport InputRow from \"../components/InputRow.svelte\";\nimport Decision from \"../components/Decision.svelte\";\nimport UserDecisions from \"../components/UserDecisions.svelte\";\nimport InfoNote from \"../components/InfoNote.svelte\";\nconst TYPE_OK = \"ok\";\nconst { setResult, getInitialData } = $props();\nlet dataToCopy = $state(\"\");\nlet title = $state(undefined);\nlet copied = $state(false);\nonMount(() => {\n    if (getInitialData) {\n        const initialData = getInitialData();\n        if (initialData) {\n            dataToCopy = initialData.dataToCopy;\n            title = initialData.title;\n        }\n    }\n});\nfunction commit() {\n    setResult(TYPE_OK);\n}\nasync function copyToClipboard() {\n    await navigator.clipboard.writeText(dataToCopy);\n    copied = true;\n}\n</script>\n\n<DialogHeader title=\"Your {title || 'Data'} is ready to be copied\" />\n<Instruction>\n    <InputRow label={title || \"Data to Copy\"}>\n        <textarea readonly rows=\"4\">{dataToCopy}</textarea>\n        <button onclick={() => copyToClipboard()}\n            >{#if !copied}üìã{:else}‚úîÔ∏è{/if}\n        </button>\n    </InputRow>\n</Instruction>\n<InfoNote visible={copied}>\n    Your {title || \"data\"} has been copied to the clipboard.\n</InfoNote>\n<UserDecisions>\n    <Decision title=\"OK\" important={true} {commit} />\n</UserDecisions>\n\n<style>\n    textarea {\n        resize: none;\n    }\n</style>\n", "<script lang=\"ts\">\"use strict\";\nconst { info } = $props();\nconst infoEntries = $derived.by(() => Object.entries(info !== null && info !== void 0 ? info : {}));\n</script>\n\n<div class=\"info-panel\">\n    <div class=\"info-grid\" role=\"list\">\n        {#each infoEntries as [key, value]}\n            <div class=\"info-entry info-key\" role=\"listitem\" aria-label={key}>\n                <div class=\"key\">{key}</div>\n            </div>\n            <div class=\"info-entry info-item\" role=\"listitem\" aria-label={key}>\n                <div class=\"value\">{value}</div>\n            </div>\n        {/each}\n    </div>\n</div>\n\n<style>\n    .info-panel {\n        padding: 0.6rem;\n        flex-grow: 1;\n    }\n\n    /* Main Grid (Info Items) 120px to 1fr, repeat */\n    .info-grid {\n        display: grid;\n        grid-template-columns:  minmax(120px, 1fr) 1fr;\n        column-count: 2;\n        gap: 0.6rem;\n        margin-top: 0.5rem;\n        grid-area: \"info-key\" \"info-value\";\n    }\n    .info-entry {\n        display: grid;\n        gap: 0.5rem;\n        border-radius: 6px;\n        box-sizing: border-box;\n        min-height: 1.2em;\n    }\n\n    .info-key {\n        font-weight: 600;\n        align-items: center;\n        border-top: 1px solid var(--background-modifier-hover);\n        border-bottom: 1px solid var(--background-modifier-hover);\n        grid-area: \"info-key\";\n    }\n    .info-item {\n        align-items: start;\n        padding: 0.5rem;\n        background: var(--background-modifier-hover, rgba(0, 0, 0, 0.03));\n        grid-area: \"info-value\";\n    }\n\n    .value {\n        white-space: pre-wrap;\n        word-break: break-word;\n        color: var(--text-normal, #e6e6e6);\n        min-height: 1em;\n    }\n\n    @container (max-width: 340px) {\n        .info-grid {\n            grid-template-columns: 1fr;\n        }\n        .info-item {\n            grid-template-columns: 1fr;\n        }\n    }\n</style>\n", "<script lang=\"ts\">import { isInvertedRegExp, isValidRegExp } from \"../../../lib/src/common/utils\";\nexport let patterns = [];\nexport let originals = [];\nexport let apply = (_) => Promise.resolve();\nfunction revert() {\n    patterns = [...originals];\n}\nconst CHECK_OK = \"‚úî\";\nconst CHECK_NG = \"‚ö†\";\nconst MARK_MODIFIED = \"‚úè \";\nfunction checkRegExp(pattern) {\n    return isValidRegExp(pattern) ? CHECK_OK : CHECK_NG;\n}\n$: statusName = patterns.map((e) => checkRegExp(e));\n$: modified = patterns.map((e, i) => { var _a; return (e != ((_a = originals === null || originals === void 0 ? void 0 : originals[i]) !== null && _a !== void 0 ? _a : \"\") ? MARK_MODIFIED : \"\"); });\n$: isInvertedExp = patterns.map((e) => isInvertedRegExp(e));\nfunction remove(idx) {\n    patterns[idx] = \"\";\n}\nfunction add() {\n    patterns = [...patterns, \"\"];\n}\n</script>\n\n<ul>\n    {#each patterns as pattern, idx}\n        <!-- svelte-ignore a11y-label-has-associated-control -->\n        <li>\n            <label>{modified[idx]}{statusName[idx]}</label>\n            <span class=\"chip\">{isInvertedExp[idx] ? \"INVERTED\" : \"\"}</span>\n            <input type=\"text\" bind:value={pattern} class={modified[idx]} />\n            <button class=\"iconbutton\" on:click={() => remove(idx)}>üóë</button>\n        </li>\n    {/each}\n    <li>\n        <label>\n            <button on:click={() => add()}>Add</button>\n        </label>\n    </li>\n    <li class=\"buttons\">\n        <button\n            on:click={() => apply(patterns)}\n            disabled={statusName.some((e) => e === CHECK_NG) || modified.every((e) => e === \"\")}\n            >Apply\n        </button>\n        <button\n            on:click={() => revert()}\n            disabled={statusName.some((e) => e === CHECK_NG) || modified.every((e) => e === \"\")}\n            >Revert\n        </button>\n    </li>\n</ul>\n\n<style>\n    label {\n        min-width: 4em;\n        width: 4em;\n        display: inline-flex;\n        flex-direction: row;\n        justify-content: flex-end;\n    }\n\n    ul {\n        flex-grow: 1;\n        display: inline-flex;\n        flex-direction: column;\n        list-style-type: none;\n        margin-block-start: 0;\n        margin-block-end: 0;\n        margin-inline-start: 0;\n        margin-inline-end: 0;\n        padding-inline-start: 0;\n    }\n\n    li {\n        padding: var(--size-2-1) var(--size-4-1);\n        display: inline-flex;\n        flex-grow: 1;\n        align-items: center;\n        justify-content: flex-end;\n        gap: var(--size-4-2);\n    }\n\n    li input {\n        min-width: 10em;\n    }\n\n    button.iconbutton {\n        max-width: 4em;\n    }\n    .chip {\n        background-color: var(--tag-background);\n        color: var(--tag-color);\n        padding: var(--size-2-1) var(--size-4-1);\n        border-radius: 0.5em;\n        font-size: 0.8em;\n    }\n    .chip:empty {\n        display: none;\n    }\n</style>\n", "<script lang=\"ts\">import { onDestroy, onMount } from \"svelte\";\nimport LogPane from \"../../../../modules/features/Log/LogPane.svelte\";\nimport { logMessages } from \"../../../../lib/src/mock_and_interop/stores\";\nfunction apiOrigin() {\n    const { protocol, hostname, port } = window.location;\n    const host = port ? `${hostname}:${port}` : hostname;\n    return `${protocol}//${host}`;\n}\nlet lastId = 0;\nlet status = $state(\"polling\");\nlet pollTimer = null;\nfunction appendLines(items) {\n    const lines = items.map((x) => x.line);\n    if (lines.length === 0)\n        return;\n    logMessages.value = [...logMessages.value, ...lines].slice(-10000);\n    lastId = Math.max(lastId, ...items.map((x) => x.id));\n}\nasync function initialLoad() {\n    const r = await fetch(`${apiOrigin()}/api/logs?since=0`);\n    const data = await r.json();\n    const items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : [];\n    logMessages.value = items.map((x) => x.line);\n    lastId = typeof (data === null || data === void 0 ? void 0 : data.lastId) === \"number\" ? data.lastId : items.length ? items[items.length - 1].id : 0;\n}\nasync function pollOnce() {\n    var _a;\n    try {\n        const r = await fetch(`${apiOrigin()}/api/logs?since=${lastId}`);\n        if (!r.ok)\n            throw new Error(`GET /api/logs failed: ${r.status}`);\n        const data = await r.json();\n        const items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : [];\n        appendLines(items);\n        status = \"polling\";\n    }\n    catch (e) {\n        status = \"error\";\n        // keep polling; transient auth/cookie issues can resolve after the next request\n        console.warn(\"Logs polling failed:\", (_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e);\n    }\n}\nfunction startPolling() {\n    status = \"polling\";\n    if (pollTimer)\n        clearInterval(pollTimer);\n    pollTimer = setInterval(() => void pollOnce(), 1000);\n    void pollOnce();\n}\nonMount(() => {\n    void (async () => {\n        await initialLoad();\n        // Polling-first: EventSource + BasicAuth is unreliable in browsers.\n        startPolling();\n    })();\n});\nonDestroy(() => {\n    if (pollTimer)\n        clearInterval(pollTimer);\n    pollTimer = null;\n});\nfunction clear() {\n    logMessages.value = [];\n    lastId = 0;\n    if (pollTimer)\n        clearInterval(pollTimer);\n    pollTimer = null;\n    startPolling();\n}\n</script>\n\n<div class=\"headless-logs-tab\">\n  <div class=\"headless-logs-toolbar\">\n    <div class=\"headless-logs-status\">Status: {status}</div>\n    <div class=\"spacer\"></div>\n    <button onclick={clear}>Clear</button>\n  </div>\n  <div class=\"headless-logs-body\">\n    <LogPane close={() => {}} />\n  </div>\n</div>\n\n<style>\n  .headless-logs-tab {\n    margin-top: 10px;\n    border: 1px solid var(--background-modifier-border);\n    border-radius: 12px;\n    background: var(--background-secondary);\n    overflow: hidden;\n  }\n  .headless-logs-toolbar {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 10px 12px;\n    border-bottom: 1px solid var(--background-modifier-border);\n    background: rgba(255, 255, 255, 0.02);\n  }\n  .headless-logs-status {\n    color: var(--text-muted);\n    font-size: 13px;\n  }\n  .spacer {\n    flex: 1;\n  }\n  .headless-logs-body {\n    height: min(70vh, 760px);\n    padding: 10px 12px;\n  }\n</style>\n\n\n", "<script lang=\"ts\">import { onDestroy, onMount } from \"svelte\";\nimport uPlot from \"uplot\";\nfunction apiOrigin() {\n    const { protocol, hostname, port } = window.location;\n    const host = port ? `${hostname}:${port}` : hostname;\n    return `${protocol}//${host}`;\n}\nlet snapshot = $state(null);\nlet outstanding = $state(0);\nlet timer = null;\nconst pollIntervalMs = 2000;\nconst historyMs = 60 * 60 * 1000;\nconst maxPoints = Math.ceil(historyMs / pollIntervalMs);\n// time series\nconst t = [];\nconst sentD = [];\nconst arrivedD = [];\nconst totalQueued = [];\nconst processing = [];\nconst batched = [];\nconst dbQ = [];\nconst storageQ = [];\nconst conflictQ = [];\nconst fileEventsQ = [];\nlet prevSent = 0;\nlet prevArrived = 0;\nlet plotThroughput = null;\nlet plotQueue = null;\nlet plotPipeline = null;\nlet plotConflicts = null;\nlet elThroughput;\nlet elQueue;\nlet elPipeline;\nlet elConflicts;\nfunction clampSeries() {\n    const extra = t.length - maxPoints;\n    if (extra <= 0)\n        return;\n    t.splice(0, extra);\n    sentD.splice(0, extra);\n    arrivedD.splice(0, extra);\n    totalQueued.splice(0, extra);\n    processing.splice(0, extra);\n    batched.splice(0, extra);\n    dbQ.splice(0, extra);\n    storageQ.splice(0, extra);\n    conflictQ.splice(0, extra);\n    fileEventsQ.splice(0, extra);\n}\nfunction setPlots() {\n    const x = t;\n    plotThroughput === null || plotThroughput === void 0 ? void 0 : plotThroughput.setData([x, sentD, arrivedD]);\n    plotQueue === null || plotQueue === void 0 ? void 0 : plotQueue.setData([x, totalQueued, processing, batched]);\n    plotPipeline === null || plotPipeline === void 0 ? void 0 : plotPipeline.setData([x, dbQ, storageQ]);\n    plotConflicts === null || plotConflicts === void 0 ? void 0 : plotConflicts.setData([x, conflictQ, fileEventsQ]);\n}\nfunction createPlot(el, title, series) {\n    const opts = {\n        title,\n        width: el.clientWidth || 900,\n        height: 240,\n        legend: { show: true },\n        scales: { x: { time: true } },\n        axes: [\n            {\n                space: 50,\n                values: (u, vals) => vals.map((v) => new Date(v * 1000).toLocaleTimeString()),\n            },\n            { space: 50 },\n        ],\n        series: [\n            { label: \"time\" },\n            ...series.map((s) => ({ label: s.label })),\n        ],\n    };\n    return new uPlot(opts, [[], ...series.map(() => [])], el);\n}\nasync function poll() {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n    const r = await fetch(`${apiOrigin()}/api/metrics`);\n    const data = await r.json();\n    snapshot = ((_a = data === null || data === void 0 ? void 0 : data.snapshot) !== null && _a !== void 0 ? _a : null);\n    outstanding = (_c = (_b = data === null || data === void 0 ? void 0 : data.derived) === null || _b === void 0 ? void 0 : _b.outstandingRequests) !== null && _c !== void 0 ? _c : 0;\n    if (!snapshot)\n        return;\n    const nowS = snapshot.ts / 1000;\n    const s = (_e = (_d = snapshot.replicationStat) === null || _d === void 0 ? void 0 : _d.sent) !== null && _e !== void 0 ? _e : 0;\n    const a = (_g = (_f = snapshot.replicationStat) === null || _f === void 0 ? void 0 : _f.arrived) !== null && _g !== void 0 ? _g : 0;\n    t.push(nowS);\n    sentD.push(Math.max(0, s - prevSent));\n    arrivedD.push(Math.max(0, a - prevArrived));\n    totalQueued.push((_h = snapshot.totalQueued) !== null && _h !== void 0 ? _h : 0);\n    processing.push((_j = snapshot.processing) !== null && _j !== void 0 ? _j : 0);\n    batched.push((_k = snapshot.batched) !== null && _k !== void 0 ? _k : 0);\n    dbQ.push((_l = snapshot.databaseQueueCount) !== null && _l !== void 0 ? _l : 0);\n    storageQ.push((_m = snapshot.storageApplyingCount) !== null && _m !== void 0 ? _m : 0);\n    conflictQ.push((_o = snapshot.conflictProcessQueueCount) !== null && _o !== void 0 ? _o : 0);\n    fileEventsQ.push((_p = snapshot.pendingFileEventCount) !== null && _p !== void 0 ? _p : 0);\n    prevSent = s;\n    prevArrived = a;\n    clampSeries();\n    setPlots();\n}\nonMount(() => {\n    // Create plots after DOM is ready.\n    plotThroughput = createPlot(elThroughput, \"Replication throughput (per tick)\", [\n        { label: \"sentŒî\" },\n        { label: \"arrivedŒî\" },\n    ]);\n    plotQueue = createPlot(elQueue, \"Queue pressure\", [\n        { label: \"totalQueued\" },\n        { label: \"processing\" },\n        { label: \"batched\" },\n    ]);\n    plotPipeline = createPlot(elPipeline, \"DB/Storage pipeline\", [\n        { label: \"databaseQueueCount\" },\n        { label: \"storageApplyingCount\" },\n    ]);\n    plotConflicts = createPlot(elConflicts, \"Conflicts & file events\", [\n        { label: \"conflictProcessQueueCount\" },\n        { label: \"pendingFileEventCount\" },\n    ]);\n    const onResize = () => {\n        // Resize plots to container width\n        const resize = (p, el) => {\n            if (!p)\n                return;\n            const w = el.clientWidth || 900;\n            p.setSize({ width: w, height: p.height });\n        };\n        resize(plotThroughput, elThroughput);\n        resize(plotQueue, elQueue);\n        resize(plotPipeline, elPipeline);\n        resize(plotConflicts, elConflicts);\n    };\n    window.addEventListener(\"resize\", onResize);\n    void poll();\n    timer = setInterval(() => void poll(), pollIntervalMs);\n    return () => window.removeEventListener(\"resize\", onResize);\n});\nonDestroy(() => {\n    if (timer)\n        clearInterval(timer);\n    plotThroughput === null || plotThroughput === void 0 ? void 0 : plotThroughput.destroy();\n    plotQueue === null || plotQueue === void 0 ? void 0 : plotQueue.destroy();\n    plotPipeline === null || plotPipeline === void 0 ? void 0 : plotPipeline.destroy();\n    plotConflicts === null || plotConflicts === void 0 ? void 0 : plotConflicts.destroy();\n});\n</script>\n\n<div class=\"headless-dashboard\">\n  <div class=\"kpis\">\n    <div class=\"kpi\">\n      <div class=\"kpi-label\">Daemon mode</div>\n      <div class=\"kpi-value\">{snapshot?.headlessMode ?? \"-\"}</div>\n    </div>\n    <div class=\"kpi\">\n      <div class=\"kpi-label\">Sync status</div>\n      <div class=\"kpi-value\">{snapshot?.replicationStat?.syncStatus ?? \"-\"}</div>\n    </div>\n    <div class=\"kpi\">\n      <div class=\"kpi-label\">Outstanding requests</div>\n      <div class=\"kpi-value\">{outstanding}</div>\n    </div>\n    <div class=\"kpi\">\n      <div class=\"kpi-label\">Queued</div>\n      <div class=\"kpi-value\">{snapshot?.totalQueued ?? 0}</div>\n    </div>\n    <div class=\"kpi\">\n      <div class=\"kpi-label\">Processing</div>\n      <div class=\"kpi-value\">{snapshot?.processing ?? 0}</div>\n    </div>\n    <div class=\"kpi kpi-wide\">\n      <div class=\"kpi-label\">Last error</div>\n      <div class=\"kpi-value kpi-value-small\">{snapshot?.headlessLastError || \"-\"}</div>\n    </div>\n  </div>\n\n  <div class=\"charts\">\n    <div class=\"chart-card\"><div bind:this={elThroughput} class=\"chart\"></div></div>\n    <div class=\"chart-card\"><div bind:this={elQueue} class=\"chart\"></div></div>\n    <div class=\"chart-card\"><div bind:this={elPipeline} class=\"chart\"></div></div>\n    <div class=\"chart-card\"><div bind:this={elConflicts} class=\"chart\"></div></div>\n  </div>\n</div>\n\n<style>\n  .kpis {\n    display: grid;\n    grid-template-columns: repeat(6, minmax(0, 1fr));\n    gap: 10px;\n    margin-top: 10px;\n  }\n  .kpi {\n    border: 1px solid var(--background-modifier-border);\n    border-radius: 12px;\n    background: var(--background-secondary);\n    padding: 12px;\n  }\n  .kpi-wide {\n    grid-column: span 2;\n  }\n  .kpi-label {\n    color: var(--text-muted);\n    font-size: 12px;\n    margin-bottom: 6px;\n  }\n  .kpi-value {\n    font-size: 18px;\n    font-weight: 650;\n  }\n  .kpi-value-small {\n    font-size: 13px;\n    font-weight: 500;\n    color: var(--text-muted);\n    word-break: break-word;\n  }\n\n  .charts {\n    margin-top: 12px;\n    display: grid;\n    grid-template-columns: repeat(2, minmax(0, 1fr));\n    gap: 10px;\n  }\n  .chart-card {\n    border: 1px solid var(--background-modifier-border);\n    border-radius: 12px;\n    background: var(--background-secondary);\n    padding: 10px;\n    overflow: hidden;\n  }\n  .chart {\n    width: 100%;\n  }\n\n  @media (max-width: 900px) {\n    .kpis {\n      grid-template-columns: repeat(2, minmax(0, 1fr));\n    }\n    .kpi-wide {\n      grid-column: span 2;\n    }\n    .charts {\n      grid-template-columns: 1fr;\n    }\n  }\n</style>\n\n\n", "<script lang=\"ts\">import { onDestroy, onMount } from \"svelte\";\nlet prompt = $state(null);\nlet status = $state(\"idle\");\nlet errMsg = $state(\"\");\nlet timer = null;\nlet inputValue = $state(\"\");\nlet lastAutoPassphraseAt = 0;\nlet lastAutoPassphraseValue = \"\";\nconst apiOrigin = () => {\n    const { protocol, hostname, port } = window.location;\n    const host = port ? `${hostname}:${port}` : hostname;\n    return `${protocol}//${host}`;\n};\nasync function pushConfigPassphraseToDaemon(passphrase) {\n    await fetch(`${apiOrigin()}/api/session/config-passphrase`, {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify({ passphrase }),\n    });\n}\nasync function postRespond(id, value) {\n    const r = await fetch(`${apiOrigin()}/api/confirm/respond`, {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify({ id, value }),\n    });\n    if (!r.ok)\n        return false;\n    try {\n        const data = await r.json();\n        return !!(data === null || data === void 0 ? void 0 : data.ok);\n    }\n    catch (_a) {\n        return false;\n    }\n}\nasync function fetchPending() {\n    var _a, _b;\n    try {\n        status = \"polling\";\n        const r = await fetch(`${apiOrigin()}/api/confirm/pending`, { method: \"GET\" });\n        if (!r.ok)\n            throw new Error(`GET /api/confirm/pending failed: ${r.status}`);\n        const data = await r.json();\n        const next = (_a = data === null || data === void 0 ? void 0 : data.prompt) !== null && _a !== void 0 ? _a : null;\n        // Reset input when a new prompt arrives.\n        if (next && (!prompt || next.id !== prompt.id))\n            inputValue = \"\";\n        // Auto-answer passphrase prompt if we already have it in localStorage.\n        if (next && next.type === \"string\" && next.key === \"ls-setting-passphrase\") {\n            const saved = localStorage.getItem(\"ls-setting-passphrase\") || \"\";\n            if (saved) {\n                // If we just auto-answered with the same value but got prompted again,\n                // the saved value is likely wrong. Clear it and require manual input.\n                if (lastAutoPassphraseValue === saved && Date.now() - lastAutoPassphraseAt < 5000) {\n                    try {\n                        localStorage.removeItem(\"ls-setting-passphrase\");\n                    }\n                    catch (_c) {\n                        // ignore\n                    }\n                    errMsg = \"Saved passphrase seems invalid. Please re-enter.\";\n                    prompt = next;\n                    return;\n                }\n                // Ensure daemon has the passphrase *before* resuming the wizard flow.\n                try {\n                    await pushConfigPassphraseToDaemon(saved);\n                }\n                catch (_d) {\n                    // ignore\n                }\n                const ok = await postRespond(next.id, saved);\n                if (ok) {\n                    lastAutoPassphraseAt = Date.now();\n                    lastAutoPassphraseValue = saved;\n                    prompt = null;\n                    errMsg = \"\";\n                    return;\n                }\n            }\n        }\n        prompt = next;\n        errMsg = \"\";\n    }\n    catch (e) {\n        status = \"error\";\n        errMsg = (_b = e === null || e === void 0 ? void 0 : e.message) !== null && _b !== void 0 ? _b : String(e);\n    }\n}\nasync function respond(value) {\n    if (!prompt)\n        return;\n    const id = prompt.id;\n    // If this prompt corresponds to a persistent browser-side key (e.g. config passphrase),\n    // store it in localStorage as the upstream plugin does.\n    if (prompt.type === \"string\" && typeof prompt.key === \"string\" && prompt.key) {\n        try {\n            localStorage.setItem(prompt.key, String(value !== null && value !== void 0 ? value : \"\"));\n        }\n        catch (_a) {\n            // ignore\n        }\n    }\n    // If the user is providing the config passphrase, push it to daemon first (in-memory only).\n    if (prompt.type === \"string\" && prompt.key === \"ls-setting-passphrase\" && typeof value === \"string\") {\n        try {\n            await pushConfigPassphraseToDaemon(value);\n        }\n        catch (_b) {\n            // ignore\n        }\n    }\n    const ok = await postRespond(id, value);\n    if (ok) {\n        // Clear only when daemon accepted the response.\n        prompt = null;\n        inputValue = \"\";\n        errMsg = \"\";\n    }\n    else {\n        errMsg = \"Failed to submit response to daemon (auth/network?).\";\n        status = \"error\";\n    }\n}\nlet renderedHtml = $state(\"\");\nasync function renderMarkdown(mdText) {\n    const { default: MarkdownIt } = await import(\"markdown-it\");\n    const md = new MarkdownIt({ html: false, linkify: true, breaks: true });\n    renderedHtml = md.render(mdText);\n}\n$effect(() => {\n    if (prompt && (prompt.type === \"confirmWithMessage\" || prompt.type === \"select\")) {\n        // message is markdown-capable for our daemon prompts.\n        void renderMarkdown(prompt.message || \"\");\n    }\n    else {\n        renderedHtml = \"\";\n    }\n});\nonMount(() => {\n    void fetchPending();\n    timer = setInterval(fetchPending, 1000);\n    return () => {\n        if (timer)\n            clearInterval(timer);\n        timer = null;\n    };\n});\n</script>\n\n{#if prompt}\n    <div class=\"sls-modal-container\" role=\"dialog\" aria-modal=\"true\">\n        <div class=\"sls-modal confirm-modal\">\n            <h2>{prompt.title ?? \"Confirmation\"}</h2>\n\n            {#if prompt.type === \"string\"}\n                <p class=\"desc\">{prompt.message}</p>\n                <input\n                    class=\"input\"\n                    type={prompt.isPassword ? \"password\" : \"text\"}\n                    placeholder={prompt.placeholder ?? \"\"}\n                    bind:value={inputValue}\n                    autofocus\n                />\n                <div class=\"actions\">\n                    <button class=\"mod-cta\" onclick={() => respond(inputValue)}>OK</button>\n                    <button onclick={() => respond(false)}>Cancel</button>\n                </div>\n            {:else}\n                <div class=\"markdown-rendered\">{@html renderedHtml}</div>\n                <div class=\"actions\">\n                    {#each prompt.buttons ?? [] as b}\n                        <button\n                            class:mod-cta={b === (prompt.defaultAction ?? \"\")}\n                            onclick={() => respond(b)}\n                        >\n                            {b}\n                        </button>\n                    {/each}\n                    {#if (prompt.buttons ?? []).length === 0}\n                        <button class=\"mod-cta\" onclick={() => respond(true)}>OK</button>\n                    {/if}\n                </div>\n            {/if}\n\n            <div class=\"footer\">\n                <span class=\"meta\">id={prompt.id}</span>\n            </div>\n        </div>\n    </div>\n{:else if status === \"error\"}\n    <!-- silent in normal case; keep minimal on error -->\n    <div class=\"sls-confirm-error\" title={errMsg}></div>\n{/if}\n\n<style>\n    .confirm-modal h2 {\n        margin: 0 0 10px;\n    }\n    .desc {\n        color: var(--text-muted);\n        margin: 0 0 10px;\n        font-size: 13px;\n    }\n    .actions {\n        display: flex;\n        gap: 10px;\n        flex-wrap: wrap;\n        margin-top: 12px;\n    }\n    .input {\n        width: 100%;\n        box-sizing: border-box;\n    }\n    .footer {\n        margin-top: 10px;\n        font-size: 12px;\n        color: var(--text-muted);\n    }\n    .sls-confirm-error {\n        display: none;\n    }\n</style>\n\n\n"],
  "mappings": "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",
  "names": []
}
